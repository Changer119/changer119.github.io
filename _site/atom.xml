<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>烂笔头</title>
 <link href="http://changer119.github.io/atom.xml" rel="self"/>
 <link href="http://changer119.github.io"/>
 <updated>2015-07-26T00:00:42+08:00</updated>
 <id>http://changer119.github.io</id>
 <author>
   <name>fcjiang</name>
   <email>fachangjiang@qq.com</email>
 </author>

 
 <entry>
   <title>Spring上手</title>
   <link href="http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/07/25/Spring%E4%B8%8A%E6%89%8B"/>
   <updated>2015-07-25T00:00:00+08:00</updated>
   <id>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/07/25/Spring上手</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>Java项目中路径Path解析</title>
   <link href="http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/07/25/Java%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%B7%AF%E5%BE%84Path%E8%A7%A3%E6%9E%90"/>
   <updated>2015-07-25T00:00:00+08:00</updated>
   <id>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/07/25/Java项目中路径Path解析</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;读取文件&lt;/h2&gt;

&lt;h3 id=&quot;resource&quot;&gt;通过Resource读取&lt;/h3&gt;

&lt;p&gt;java语言中Class对象有一个方法&lt;em&gt;getResource()&lt;/em&gt;，通过这个方法可以读取文件。但它有一个缺点，就是只能读取放在编译后目录中文件，对于那些在src源码目录中存在但没有编译到classpath目录中的文件是读取不到的。&lt;/p&gt;

&lt;p&gt;利用maven管理工程时，&lt;em&gt;projectName/src/main/java/&lt;/em&gt;目录下放源码，&lt;em&gt;projectName/src/main/resources/&lt;/em&gt;目录下放资源文件。&lt;/p&gt;

&lt;p&gt;编译后，maven会生成一个&lt;em&gt;projectName/target&lt;/em&gt;目录，下面会有一个&lt;em&gt;classes&lt;/em&gt;目录，&lt;em&gt;project/target/classes/&lt;/em&gt;目录就整个工程的classpath。源码编译后的.class文件就按照package结构放在classes目录下，&lt;em&gt;projectName/src/main/resources/&lt;/em&gt;下的资源房间也会自动放到classes根目录下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.qiniudn.com/QQ20150725-2.png&quot; alt=&quot;源码结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是一个工程的文件结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.qiniudn.com/QQ20150725-1.png&quot; alt=&quot;源码结构&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// aa1Url是null，获取不到aa1.txt
// aa1.txt aa2.txt都是在java源代码所在的目录，不会编译到target目录下，所以getResource访问不到。
URL aa1Url = ResourceTest.class.getResource(&quot;aa1.txt&quot;);
File aa1 = new File(aa1Url.getFile());

// 必须在aa3.txt前加/，表示是classess根目录下的aa3.txt，如果不加/，则需要main/resources目录下有一个和ResourceTest包结构一模一样的路径来存放aa3.txt
URL aa3Url = ResourceTest.class.getResource(&quot;/aa3.txt&quot;);
File aa3 = new File(aa3Url.getFile());

URL aa4Url = ResourceTest.class.getResource(&quot;/config/aa4.txt&quot;);
File aa4 = new File(aa4Url.getFile());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;建议：使用getResource时，都加上/，从classes根目录下计算相对路径&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getResource有一个变种getResourceAsStream，具体使用可google&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;classpath&quot;&gt;题外话（如何查看工程的classpath呢？）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// /表示classpath所在的根路径
URL url = ResourceTest.class.getResource(&quot;/&quot;);
System.out.println(url);
// 输出file:/Users/fcjiang/projectName.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，估计有人纳闷了，难道main/java源码结构下的文件就不能读取啦？getResource方式是不行了，可以用&lt;strong&gt;File去读取&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;file&quot;&gt;通过File读取文件&lt;/h2&gt;

&lt;p&gt;上例中的aa1.txt和aa2.txt文件可以通过File+绝对路径的方式读取。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File aa1 = new File(&quot;/Users/fcjiang/projectName/src/main/java/com/changer/app/aa1.txt&quot;);
File aa1 = new File(&quot;/Users/fcjiang/projectName/src/main/java/com/changer/aa2.txt&quot;);
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Beyond Compare 4试用版破解</title>
   <link href="http://changer119.github.io/%E5%96%84%E5%81%87%E4%BA%8E%E7%89%A9/2015/07/21/Beyond%20Compare%204%E8%AF%95%E7%94%A8%E7%89%88%E7%A0%B4%E8%A7%A3"/>
   <updated>2015-07-21T00:00:00+08:00</updated>
   <id>http://changer119.github.io/%E5%96%84%E5%81%87%E4%BA%8E%E7%89%A9/2015/07/21/Beyond Compare 4试用版破解</id>
   <content type="html">&lt;p&gt;&lt;em&gt;以下方法亲测可用&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Beyond Compare试用版在本地磁盘上会保留一个dat文件，这个文件会记录你使用Beyond Compare多久了，还有多久逾期。30天期满后，就不能在使用Beyond Compare了。要想继续使用，只要删除该dat文件即可。不过这个删除操作每30天要执行一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm /Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更加详细的，一劳永逸的方法，可参照&lt;a href=&quot;http://www.puteulanus.com/archives/677&quot;&gt;Beyond Compare 4 for Mac 无限试用版&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>互联网金融监管意见发布</title>
   <link href="http://changer119.github.io/2015/07/18/%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D%E7%9B%91%E7%AE%A1%E6%84%8F%E8%A7%81%E5%8F%91%E5%B8%83"/>
   <updated>2015-07-18T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/18/互联网金融监管意见发布</id>
   <content type="html">&lt;p&gt;2015年7月18日，国家终于发布了&lt;strong&gt;互联网金融监管意见&lt;/strong&gt;。这份意见是10部委联合起草的，目前还只是框架性建议。具体的监管细节文件还在草拟中。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[全文如下]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;近年来，互联网技术、信息通信技术不断取得突破，推动互联网与金融快速融合，促进了金融创新，提高了金融资源配置效率，但也存在一些问题和风险隐患。为全面贯彻落实党的十八大和十八届二中、三中、四中全会精神，按照党中央、国务院决策部署，遵循“鼓励创新、防范风险、趋利避害、健康发展”的总体要求，从金融业健康发展全局出发，进一步推进金融改革创新和对外开放，促进互联网金融健康发展，经党中央、国务院同意，现提出以下意见。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、鼓励创新，支持互联网金融稳步发展&lt;/h3&gt;

&lt;p&gt;互联网金融是传统金融机构与互联网企业(以下统称从业机构)利用互联网技术和信息通信技术实现资金融通、支付、投资和信息中介服务的新型金融业务模式。互联网与金融深度融合是大势所趋，将对金融产品、业务、组织和服务等方面产生更加深刻的影响。互联网金融对促进小微企业发展和扩大就业发挥了现有金融机构难以替代的积极作用，为大众创业、万众创新打开了大门。促进互联网金融健康发展，有利于提升金融服务质量和效率，深化金融改革，促进金融创新发展，扩大金融业对内对外开放，构建多层次金融体系。作为新生事物，互联网金融既需要市场驱动，鼓励创新，也需要政策助力，促进发展。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(一)积极鼓励互联网金融平台、产品和服务创新，激发市场活力。&lt;/strong&gt;鼓励银行、证券、保险、基金、信托和消费金融等金融机构依托互联网技术，实现传统金融业务与服务转型升级，积极开发基于互联网技术的新产品和新服务。支持有条件的金融机构建设创新型互联网平台开展网络银行、网络证券、网络保险、网络基金销售和网络消费金融等业务。支持互联网企业依法合规设立互联网支付机构、网络借贷平台、股权众筹融资平台、网络金融产品销售平台，建立服务实体经济的多层次金融服务体系，更好地满足中小微企业和个人投融资需求，进一步拓展普惠金融的广度和深度。鼓励电子商务企业在符合金融法律法规规定的条件下自建和完善线上金融服务体系，有效拓展电商供应链业务。鼓励从业机构积极开展产品、服务、技术和管理创新，提升从业机构核心竞争力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(二)鼓励从业机构相互合作，实现优势互补。&lt;/strong&gt;支持各类金融机构与互联网企业开展合作，建立良好的互联网金融生态环境和产业链。鼓励银行业金融机构开展业务创新，为第三方支付机构和网络贷款平台等提供资金存管、支付清算等配套服务。支持小微金融服务机构与互联网企业开展业务合作，实现商业模式创新。支持证券、基金、信托、消费金融、期货机构与互联网企业开展合作，拓宽金融产品销售渠道，创新财富管理模式。鼓励保险公司与互联网企业合作，提升互联网金融企业风险抵御能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(三)拓宽从业机构融资渠道，改善融资环境。&lt;/strong&gt;支持社会资本发起设立互联网金融产业投资基金，推动从业机构与创业投资机构、产业投资基金深度合作。鼓励符合条件的优质从业机构在主板、创业板等境内资本市场上市融资。鼓励银行业金融机构按照支持小微企业发展的各项金融政策，对处于初创期的从业机构予以支持。针对互联网企业特点，创新金融产品和服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(四)坚持简政放权，提供优质服务。&lt;/strong&gt;各金融监管部门要积极支持金融机构开展互联网金融业务。按照法律法规规定，对符合条件的互联网企业开展相关金融业务实施高效管理。工商行政管理部门要支持互联网企业依法办理工商注册登记。电信主管部门、国家互联网信息管理部门要积极支持互联网金融业务，电信主管部门对互联网金融业务涉及的电信业务进行监管，国家互联网信息管理部门负责对金融信息服务、互联网信息内容等业务进行监管。积极开展互联网金融领域立法研究，适时出台相关管理规章，营造有利于互联网金融发展的良好制度环境。加大对从业机构专利、商标等知识产权的保护力度。鼓励省级人民政府加大对互联网金融的政策支持。支持设立专业化互联网金融研究机构，鼓励建设互联网金融信息交流平台，积极开展互联网金融研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(五)落实和完善有关财税政策。&lt;/strong&gt;按照税收公平原则，对于业务规模较小、处于初创期的从业机构，符合我国现行对中小企业特别是小微企业税收政策条件的，可按规定享受税收优惠政策。结合金融业营业税改征增值税改革，统筹完善互联网金融税收政策。落实从业机构新技术、新产品研发费用税前加计扣除政策。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(六)推动信用基础设施建设，培育互联网金融配套服务体系。&lt;/strong&gt;支持大数据存储、网络与信息安全维护等技术领域基础设施建设。鼓励从业机构依法建立信用信息共享平台。推动符合条件的相关从业机构接入金融信用信息基础数据库。允许有条件的从业机构依法申请征信业务许可。支持具备资质的信用中介组织开展互联网企业信用评级，增强市场信息透明度。鼓励会计、审计、法律、咨询等中介服务机构为互联网企业提供相关专业服务。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、分类指导，明确互联网金融监管责任&lt;/h3&gt;

&lt;p&gt;互联网金融本质仍属于金融，没有改变金融风险隐蔽性、传染性、广泛性和突发性的特点。加强互联网金融监管，是促进互联网金融健康发展的内在要求。同时，互联网金融是新生事物和新兴业态，要制定适度宽松的监管政策，为互联网金融创新留有余地和空间。通过鼓励创新和加强监管相互支撑，促进互联网金融健康发展，更好地服务实体经济。互联网金融监管应遵循“依法监管、适度监管、分类监管、协同监管、创新监管”的原则，科学合理界定各业态的业务边界及准入条件，落实监管责任，明确风险底线，保护合法经营，坚决打击违法和违规行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(七)  互联网支付。&lt;/strong&gt;互联网支付是指通过计算机、手机等设备，依托互联网发起支付指令、转移货币资金的服务。互联网支付应始终坚持服务电子商务发展和为社会提供小额、快捷、便民小微支付服务的宗旨。银行业金融机构和第三方支付机构从事互联网支付，应遵守现行法律法规和监管规定。第三方支付机构与其他机构开展合作的，应清晰界定各方的权利义务关系，建立有效的风险隔离机制和客户权益保障机制。要向客户充分披露服务信息，清晰地提示业务风险，不得夸大支付服务中介的性质和职能。互联网支付业务由人民银行负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(八)网络借贷。&lt;/strong&gt;网络借贷包括个体网络借贷(即P2P网络借贷)和网络小额贷款。个体网络借贷是指个体和个体之间通过互联网平台实现的直接借贷。在个体网络借贷平台上发生的直接借贷行为属于民间借贷范畴，受合同法、民法通则等法律法规以及最高人民法院相关司法解释规范。个体网络借贷要坚持平台功能，为投资方和融资方提供信息交互、撮合、资信评估等中介服务。个体网络借贷机构要明确信息中介性质，主要为借贷双方的直接借贷提供信息服务，不得提供增信服务，不得非法集资。网络小额贷款是指互联网企业通过其控制的小额贷款公司，利用互联网向客户提供的小额贷款。网络小额贷款应遵守现有小额贷款公司监管规定，发挥网络贷款优势，努力降低客户融资成本。网络借贷业务由银监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(九)股权众筹融资。&lt;/strong&gt;股权众筹融资主要是指通过互联网形式进行公开小额股权融资的活动。股权众筹融资必须通过股权众筹融资中介机构平台(互联网网站或其他类似的电子媒介)进行。股权众筹融资中介机构可以在符合法律法规规定前提下，对业务模式进行创新探索，发挥股权众筹融资作为多层次资本市场有机组成部分的作用，更好服务创新创业企业。股权众筹融资方应为小微企业，应通过股权众筹融资中介机构向投资人如实披露企业的商业模式、经营管理、财务、资金使用等关键信息，不得误导或欺诈投资者。投资者应当充分了解股权众筹融资活动风险，具备相应风险承受能力，进行小额投资。股权众筹融资业务由证监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十)互联网基金销售。&lt;/strong&gt;基金销售机构与其他机构通过互联网合作销售基金等理财产品的，要切实履行风险披露义务，不得通过违规承诺收益方式吸引客户；基金管理人应当采取有效措施防范资产配置中的期限错配和流动性风险；基金销售机构及其合作机构通过其他活动为投资人提供收益的，应当对收益构成、先决条件、适用情形等进行全面、真实、准确表述和列示，不得与基金产品收益混同。第三方支付机构在开展基金互联网销售支付服务过程中，应当遵守人民银行、证监会关于客户备付金及基金销售结算资金的相关监管要求。第三方支付机构的客户备付金只能用于办理客户委托的支付业务，不得用于垫付基金和其他理财产品的资金赎回。互联网基金销售业务由证监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十一)互联网保险。&lt;/strong&gt;保险公司开展互联网保险业务，应遵循安全性、保密性和稳定性原则，加强风险管理，完善内控系统，确保交易安全、信息安全和资金安全。专业互联网保险公司应当坚持服务互联网经济活动的基本定位，提供有针对性的保险服务。保险公司应建立对所属电子商务公司等非保险类子公司的管理制度，建立必要的防火墙。保险公司通过互联网销售保险产品，不得进行不实陈述、片面或夸大宣传过往业绩、违规承诺收益或者承担损失等误导性描述。互联网保险业务由保监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十二)互联网信托和互联网消费金融。&lt;/strong&gt;信托公司、消费金融公司通过互联网开展业务的，要严格遵循监管规定，加强风险管理，确保交易合法合规，并保守客户信息。信托公司通过互联网进行产品销售及开展其他信托业务的，要遵守合格投资者等监管规定，审慎甄别客户身份和评估客户风险承受能力，不能将产品销售给与风险承受能力不相匹配的客户。信托公司与消费金融公司要制定完善产品文件签署制度，保证交易过程合法合规，安全规范。互联网信托业务、互联网消费金融业务由银监会负责监管。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、健全制度，规范互联网金融市场秩序&lt;/h3&gt;

&lt;p&gt;发展互联网金融要以市场为导向，遵循服务实体经济、服从宏观调控和维护金融稳定的总体目标，切实保障消费者合法权益，维护公平竞争的市场秩序。要细化管理制度，为互联网金融健康发展营造良好环境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十三)互联网行业管理。&lt;/strong&gt;任何组织和个人开设网站从事互联网金融业务的，除应按规定履行相关金融监管程序外，还应依法向电信主管部门履行网站备案手续，否则不得开展互联网金融业务。工业和信息化部负责对互联网金融业务涉及的电信业务进行监管，国家互联网信息办公室负责对金融信息服务、互联网信息内容等业务进行监管，两部门按职责制定相关监管细则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十四)客户资金第三方存管制度。&lt;/strong&gt;除另有规定外，从业机构应当选择符合条件的银行业金融机构作为资金存管机构，对客户资金进行管理和监督，实现客户资金与从业机构自身资金分账管理。客户资金存管账户应接受独立审计并向客户公开审计结果。人民银行会同金融监管部门按照职责分工实施监管，并制定相关监管细则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十五)信息披露、风险提示和合格投资者制度。&lt;/strong&gt;从业机构应当对客户进行充分的信息披露，及时向投资者公布其经营活动和财务状况的相关信息，以便投资者充分了解从业机构运作状况，促使从业机构稳健经营和控制风险。从业机构应当向各参与方详细说明交易模式、参与方的权利和义务，并进行充分的风险提示。要研究建立互联网金融的合格投资者制度，提升投资者保护水平。有关部门按照职责分工负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十六)消费者权益保护。&lt;/strong&gt;研究制定互联网金融消费者教育规划，及时发布维权提示。加强互联网金融产品合同内容、免责条款规定等与消费者利益相关的信息披露工作，依法监督处理经营者利用合同格式条款侵害消费者合法权益的违法、违规行为。构建在线争议解决、现场接待受理、监管部门受理投诉、第三方调解以及仲裁、诉讼等多元化纠纷解决机制。细化完善互联网金融个人信息保护的原则、标准和操作流程。严禁网络销售金融产品过程中的不实宣传、强制捆绑销售。人民银行、银监会、证监会、保监会会同有关行政执法部门，根据职责分工依法开展互联网金融领域消费者和投资者权益保护工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十七)网络与信息安全。&lt;/strong&gt;从业机构应当切实提升技术安全水平，妥善保管客户资料和交易信息，不得非法买卖、泄露客户个人信息。人民银行、银监会、证监会、保监会、工业和信息化部、公安部、国家互联网信息办公室分别负责对相关从业机构的网络与信息安全保障进行监管，并制定相关监管细则和技术安全标准。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十八)反洗钱和防范金融犯罪。&lt;/strong&gt;从业机构应当采取有效措施识别客户身份，主动监测并报告可疑交易，妥善保存客户资料和交易记录。从业机构有义务按照有关规定，建立健全有关协助查询、冻结的规章制度，协助公安机关和司法机关依法、及时查询、冻结涉案财产，配合公安机关和司法机关做好取证和执行工作。坚决打击涉及非法集资等互联网金融犯罪，防范金融风险，维护金融秩序。金融机构在和互联网企业开展合作、代理时应根据有关法律和规定签订包括反洗钱和防范金融犯罪要求的合作、代理协议，并确保不因合作、代理关系而降低反洗钱和金融犯罪执行标准。人民银行牵头负责对从业机构履行反洗钱义务进行监管，并制定相关监管细则。打击互联网金融犯罪工作由公安部牵头负责。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十九)加强互联网金融行业自律。&lt;/strong&gt;充分发挥行业自律机制在规范从业机构市场行为和保护行业合法权益等方面的积极作用。人民银行会同有关部门，组建中国互联网金融协会。协会要按业务类型，制订经营管理规则和行业标准，推动机构之间的业务交流和信息共享。协会要明确自律惩戒机制，提高行业规则和标准的约束力。强化守法、诚信、自律意识，树立从业机构服务经济社会发展的正面形象，营造诚信规范发展的良好氛围。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(二十)监管协调与数据统计监测。&lt;/strong&gt;各监管部门要相互协作、形成合力，充分发挥金融监管协调部际联席会议制度的作用。人民银行、银监会、证监会、保监会应当密切关注互联网金融业务发展及相关风险，对监管政策进行跟踪评估，适时提出调整建议，不断总结监管经验。财政部负责互联网金融从业机构财务监管政策。人民银行会同有关部门，负责建立和完善互联网金融数据统计监测体系，相关部门按照监管职责分工负责相关互联网金融数据统计和监测工作，并实现统计数据和信息共享。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[全文完]&lt;/em&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Spring @Transactional事务管理</title>
   <link href="http://changer119.github.io/2015/07/15/Spring%20@Transactional%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"/>
   <updated>2015-07-15T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/15/Spring @Transactional事务管理</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;事务是什么？&lt;/h3&gt;

&lt;h3 id=&quot;spring&quot;&gt;Spring的事务管理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring的事务管理由注解@Transactional实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既可以在类上添加@Transactional，也可以在方法上添加@Transactional。在类前加上@Transactional，声明这个类的所有方法都需要事务管理，每一个业务方法开始时都会打开一个事务。在方法前添加@Transactional，表示这一个方法需要进行事务管理。&lt;/p&gt;

&lt;p&gt;Spring默认情况下会对运行期异常(RunTimeException)进行事务回滚，Unchecked Exception异常除外。&lt;/p&gt;

&lt;p&gt;如何改变默认规则：&lt;/p&gt;

&lt;p&gt;1 让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class)&lt;/p&gt;

&lt;p&gt;2 让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)&lt;/p&gt;

&lt;p&gt;3 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED)&lt;/p&gt;

&lt;p&gt;在整个方法运行前就不会开启事务&lt;/p&gt;

&lt;p&gt;单独使用 @Transactional 注释时，事务传播模式被设置成什么呢？只读标志被设置成什么呢？事务隔离级别的设置是怎样的？更重要的是，事务应何时回滚工作？理解如何使用这个注释对于确保在应用程序中获得合适的事务支持级别非常重要。回答我刚才提出的问题：在单独使用不带任何参数的 @Transactional 注释时，传播模式要设置为 REQUIRED，只读标志设置为 false，事务隔离级别设置为 READ_COMMITTED，而且事务不会针对受控异常（checked exception）回滚。&lt;/p&gt;

&lt;h3 id=&quot;transactional&quot;&gt;@Transactional的事务传递&lt;/h3&gt;
&lt;p&gt;id	|	amount
—————-| —————
1 |   1000&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;问题是什么&lt;/h2&gt;

&lt;p&gt;假设有一张表T_ACCOUNT，它的字段如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有两个线程：A和B。A需要给id=1的用户增加300元，而B需要给id=1的记录减掉100元。 可能的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithId(int id, int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果A先执行，B后执行，最后的amount的值为1200。如果B先执行，A后执行，最后的结果也是1200.最担心的情况的是，A和B同时执行。A、B两个线程同时读取到当前的值（1000），每个线程会将这个数据保存在自身的栈里。然后，A、B会竞争去做update操作，数据库引擎会保证同一时刻只有一个线程在update。如果A先做了update操作，DB中的amount会变成1300。这时B再做update，由于B已经将amount的值保留在栈内了（值为之前取到的1000），update之后，amount会变为900. 这明显不符合逻辑，多并发引起了数据的不一致。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何解决&lt;/h2&gt;

&lt;h3 id=&quot;versionid&quot;&gt;方式1（利用versionId）&lt;/h3&gt;

&lt;p&gt;在设计表的时候，多预留一个字段为version_id。它是一个普通的int类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
      &lt;th&gt;version_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在定义方法的时候，要增加一个versionId进去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithIdAndVersionId(int id, int versionId,int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当A、B同时执行。A和B先查询记录，发现id=1，versionId=1，并将结果保存在自己的栈内。当执行update操作时，总会有一个先执行。假设A先执行，A在调用updateWithIdAndVersionId方法时，程序需要&lt;strong&gt;将versionId加1&lt;/strong&gt;，这样一来，DB中id=1的记录的version_id就是2了。当B再执行updateWithIdAndVersionId操作，它根据2个条件（id=1、versionId=1）去更新。因为此时DB中已不存在这条记录了，所以更新失败。通过这种方法就可以保证多并发对数据操作的一致性。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>多并发下的DB更新</title>
   <link href="http://changer119.github.io/2015/07/14/%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84DB%E6%9B%B4%E6%96%B0"/>
   <updated>2015-07-14T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/14/多并发下的DB更新</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;问题是什么&lt;/h2&gt;

&lt;p&gt;假设有一张表T_ACCOUNT，它的字段如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有两个线程：A和B。A需要给id=1的用户增加300元，而B需要给id=1的记录减掉100元。 可能的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithId(int id, int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果A先执行，B后执行，最后的amount的值为1200。如果B先执行，A后执行，最后的结果也是1200.最担心的情况的是，A和B同时执行。A、B两个线程同时读取到当前的值（1000），每个线程会将这个数据保存在自身的栈里。然后，A、B会竞争去做update操作，数据库引擎会保证同一时刻只有一个线程在update。如果A先做了update操作，DB中的amount会变成1300。这时B再做update，由于B已经将amount的值保留在栈内了（值为之前取到的1000），update之后，amount会变为900. 这明显不符合逻辑，多并发引起了数据的不一致。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何解决&lt;/h2&gt;

&lt;h3 id=&quot;versionid&quot;&gt;方式1（利用versionId）&lt;/h3&gt;

&lt;p&gt;在设计表的时候，多预留一个字段为version_id。它是一个普通的int类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
      &lt;th&gt;version_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在定义方法的时候，要增加一个versionId进去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithIdAndVersionId(int id, int versionId,int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当A、B同时执行。A和B先查询记录，发现id=1，versionId=1，并将结果保存在自己的栈内。当执行update操作时，总会有一个先执行。假设A先执行，A在调用updateWithIdAndVersionId方法时，程序需要&lt;strong&gt;将versionId加1&lt;/strong&gt;，这样一来，DB中id=1的记录的version_id就是2了。当B再执行updateWithIdAndVersionId操作，它根据2个条件（id=1、versionId=1）去更新。因为此时DB中已不存在这条记录了，所以更新失败。通过这种方法就可以保证多并发对数据操作的一致性。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jekyll bootstrap主题安装</title>
   <link href="http://changer119.github.io/2015/07/08/jekyll-bootstrap-%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85"/>
   <updated>2015-07-08T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/08/jekyll-bootstrap-主题安装</id>
   <content type="html">&lt;p&gt;在安装bootsrap dinky主题后，本地运行jekyll是没问题的，但一上传到github.com后，就会报下面的错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The page build failed with the following error:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The submodule &lt;code&gt;_theme_packages/dinky&lt;/code&gt; was not properly initialized with a &lt;code&gt;.gitmodules&lt;/code&gt; file. For more information, see https://help.github.com/articles/page-build-failed-missing-submodule.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you have any questions you can contact us by replying to this email.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;笔者也很有耐心的去看了上文中的链接，结果怎么试都不行，后来在网上也找了很多其他的教程，依然解决不了。直到看到下面这两篇文章（&lt;a href=&quot;http://theloverz.me/note/2013/12/06/fix-failure-on-github-pages-and-jekyll/&quot;&gt;文章1&lt;/a&gt;，&lt;a href=&quot;http://dsimidzija.github.io/programming/2014/02/15/jekyll-bootstrap-themes-and-github-pages/&quot;&gt;文章2&lt;/a&gt;），才解决了问题。&lt;/p&gt;

&lt;p&gt;下面我介绍下我的步骤。&lt;/p&gt;

&lt;p&gt;1，进入博客的主目录(我的是changer119.github.io)，在.gitignore文件中添加如下内容。如果主目录下没有.gitignore文件，自己新增一个即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*.swp
_site/*
_theme_packages/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上内容表示，_site和 _theme_package两个目录都不加到git，也不上传到github。&lt;/p&gt;

&lt;p&gt;2，在主目录下删除已有的_theme_packages内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rm -r --cached _theme_packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, 重新安装jekyll bootstrap的主题。&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-theming.html#toc_3&quot;&gt;官方链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我使用的dinky主题，我在主目录下输入如下命令，碰到需要选择的时候，一直yes下去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rake theme:install git=&quot;git://github.com/sodabrew/theme-dinky.git&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，本地run一下jekyll，看看效果。在主目录下执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5，查看效果，访问&lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6，如果效果正常，就可以提交修改到github啦。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add *
git commit -m &#39;your log&#39;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>maven入门</title>
   <link href="http://changer119.github.io/2015/07/08/Maven%E5%85%A5%E9%97%A8"/>
   <updated>2015-07-08T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/08/Maven入门</id>
   <content type="html">&lt;h2 id=&quot;maven&quot;&gt;maven主要命令&lt;/h2&gt;

&lt;h3 id=&quot;test&quot;&gt;安装但不运行test代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Dmaven.test.skip=true
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;profile&quot;&gt;指定profile安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pint	# 给测试发的版本
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pdev	# 给开发发的版本
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;profiletest&quot;&gt;指定profile，不运行test（合并）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pint -Dmaven.test.skip=true
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven-1&quot;&gt;maven聚合&lt;/h2&gt;
&lt;p&gt;假设有projectA，它里面聚合了projectB、projectC两个模块，projectA的pom.xml中的&lt;code&gt;&amp;lt;packaging&amp;gt;&lt;/code&gt;属性值必须为pom。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1 id=&quot;maven-2&quot;&gt;Maven参数配置&lt;/h1&gt;

&lt;h2 id=&quot;packaging-&quot;&gt;packaging 打包类型&lt;/h2&gt;

&lt;p&gt;任何一个maven工程，对应有一个pom.xml文件。这个pom.xml文件通过&lt;code&gt;&amp;lt;packaging&amp;gt;xxx&amp;lt;/packaging&amp;gt;&lt;/code&gt;来决定该工程打包的类型（打成jar包？war包？）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不填时（默认），表示打成jar包。&lt;/li&gt;
  &lt;li&gt;war，表示打成war包。&lt;/li&gt;
  &lt;li&gt;pom，表示这个工程不打包，它是其它工程的父工程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;nexus&quot;&gt;Nexus相关&lt;/h1&gt;

&lt;p&gt;Nexus安装之后，会自动配置下面这几个仓库。如图：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图片&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;这里面的仓库主要有三种类型： &lt;code&gt;hosted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;proxy&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;group&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;hosted&lt;/strong&gt;: 主要与公司内部打交道。例如用户发布包（&lt;code&gt;mvn deploy&lt;/code&gt;）就会将包上传到&lt;code&gt;hosted&lt;/code&gt;类别的仓库中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Releases仓库：当工程pom的version为x.x.x-Release时，用户发布后会将包上传到该仓库。&lt;/li&gt;
  &lt;li&gt;Snapshots仓库：与上逻辑同。&lt;/li&gt;
  &lt;li&gt;3rd part仓库：如果有些依赖包在maven的中央仓库找不到，就需要到该依赖包的官网下载，让后将依赖包上传到该仓库中。用户下次添加依赖时，会直接到该仓库获取。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;proxy&lt;/strong&gt;: 主要与外网打交道。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Centeral仓库：从maven中央仓库下载的包都放在该仓库。&lt;/li&gt;
  &lt;li&gt;Apache Snapshots仓库：放从apache下载的包。&lt;/li&gt;
  &lt;li&gt;Codehause Snapshots仓库：放从codehause下载的包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;设置mirror后，工程只会访问镜像，如果程序访问不了镜像，也不会去访问中央工厂回到家后，无法访问mirror时，就需要注释mirror，程序才会去中央工厂下载&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;mvn-deploy&quot;&gt;发布（mvn deploy）&lt;/h2&gt;

&lt;p&gt;要将包发布到私服上，需要先在pom中设置&lt;code&gt;&amp;lt;distributionManagement&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;server&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图片1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pic2&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven-3&quot;&gt;Maven的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;有3套生命周期：clean的生命周期、compile的生命周期、site的生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下图列出了执行mvn clean和mvn install需要完成的步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-2@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-3@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件的配置&lt;/h2&gt;

&lt;p&gt;表示在执行完validate之后，就会执行jar和test-jar操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-4@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;**在父级pom中，有&lt;code&gt;&amp;lt;pluginsManagement&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;标签，在它里面定义的内容不能够被子模块直接继承，需要在子模块中手动添加groupid和archtypeId才行**&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>测试图片显示</title>
   <link href="http://changer119.github.io/2015/07/07/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87"/>
   <updated>2015-07-07T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/07/测试使用图片</id>
   <content type="html">&lt;p&gt;情况1：图片放在changer119.github.io本地目录下。&lt;/p&gt;

&lt;p&gt;需要找到./assets/images/目录，将图片放到该目录下。在调用图片的地方使用如下语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![图片说明](http://changer119.github.io/assets/images/1.jpg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.github.io/assets/images/1.jpg&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;p&gt;情况2：图片放在qiniu上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何配置qiniu 可参照&lt;/strong&gt; &lt;a href=&quot;http://developer.qiniu.com/docs/v6/tools/qrsync.html#download&quot;&gt;七牛官方配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先将图片放在&lt;em&gt;/Users/fcjiang/qiniu-sync/QQSnapShot/&lt;/em&gt;目录下。&lt;/p&gt;

&lt;p&gt;然后启用qiniu的同步工具：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qrsync //Users/fcjiang/Software/qiniu-devtools-darwin_amd64-v3.1.20150620/conf.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片会自动上传到qiniu服务器的changer119目录中。&lt;/p&gt;

&lt;p&gt;要使用时，只需要&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![图片说明](http://changer119.qiniudn.com/QQ20150720-2.png)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.qiniudn.com/QQ20150720-2.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>java枚举类型初体验</title>
   <link href="http://changer119.github.io/2015/07/07/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8"/>
   <updated>2015-07-07T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/07/Java枚举类型使用</id>
   <content type="html">&lt;p&gt;Enum是JDK5引入的。有了Enum类型后，对于常量的处理更加方便。&lt;/p&gt;

&lt;p&gt;以前定义常量一般是这样的：&lt;/p&gt;

&lt;p&gt;```
Constant.java&lt;/p&gt;

&lt;p&gt;public interface Constant{
	public final PI = 3.14;
	public fianl G = 9.8;
}
```&lt;/p&gt;

&lt;p&gt;以前这些常量可能分散在不同的文件中，缺乏统一的管理，使用不方便。&lt;/p&gt;

&lt;p&gt;利用Enum类型，可以将常量定义成如下形式：&lt;/p&gt;

&lt;p&gt;```
ColorEnum.java&lt;/p&gt;

&lt;p&gt;public enum ColorEnum{
	RED, GREEN, YELLOW;
}
```&lt;/p&gt;

&lt;p&gt;如果觉得上面的枚举太过简单，可以给ColorEnum添加方法。&lt;/p&gt;

&lt;p&gt;```
public enum Color {
    // 必须先定义枚举类Color的实例
    Red(1, “红色”),
    Green(2, “绿色”),
    Yellow(3, “黄色”),
    Pink(4, “粉红色”);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final int id;
private final String description;


// 根据id值得到对应的description
public static String getDescription(int id){
    for(Color item : Color.values()){
        if(item.getId() == id){
            return item.getDescription();
        }
    }
    return null;
}
// 根据id值得到对应的枚举实例
public static Color getColor(int id){
    for(Color item : Color.values()){
        if(item.getId() == id){
            return item;
        }
    }
    return null;
}
// 根据id值得到对应的枚举实例
public static Color valueOf(int id){
    switch (id){
        case 1:
            return Color.Red;
        case 2:
            return Color.Green;
        case 3:
            return Color.Yellow;
        case 4:
            return Color.Pink;
        default:
            return  null;
    }
}

//覆盖方法
@Override
public String toString() {
    return this.id+&quot;_&quot; + this.description;
}

Color(int id, String description) {
    this.id = id;
    this.description = description;
}

public int getId() {
    return id;
}

public String getDescription() {
    return description;
}

// 枚举类里面可以添加main方法
public static void main(String[] args){
    int id = 2;
    Color c = Color.getColor(2);
    System.out.println(c);
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义枚举类时，枚举实例必须放在最前面，并且已&lt;code&gt;;&lt;/code&gt;分号隔开。&lt;/li&gt;
  &lt;li&gt;枚举实例&lt;code&gt;Red(1, &quot;红色&quot;)&lt;/code&gt;，是根据枚举类的定义得来的。（枚举类有id, description两个成员变量）&lt;/li&gt;
  &lt;li&gt;这种枚举类主要用在数据库的状态字段中。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Intellij使用</title>
   <link href="http://changer119.github.io/2015/07/07/Intellij%E4%BD%BF%E7%94%A8"/>
   <updated>2015-07-07T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/07/Intellij使用</id>
   <content type="html">&lt;h2 id=&quot;svnmaven&quot;&gt;导出svn上的maven工程&lt;/h2&gt;

&lt;p&gt;1, 新建Maven工程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.github.io/assets/images/QQ20150720-1.png&quot; alt=&quot;从svn新建项目&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2，在IdeaWorspace目录下，新建一个文件夹，名字和checkout的分支名一样。然后将新工程指定放在该目录下，开始checkout代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.github.io/assets/images/QQ20150720-2.png&quot; alt=&quot;新建文件夹&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3，代码checkout到本地后，查看代码发现都有红色的问号（表示有错误）。这是因为Intellij没有自动刷新导致的。只要点击Intellij右侧MavenProjects，再点击刷新图标即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.github.io/assets/images/QQ20150707-1@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intellij&quot;&gt;Intellij常用快捷键&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;组合键&lt;/th&gt;
      &lt;th&gt;实现的功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;替换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;alt + F7&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找方法或者类被引用的地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;double shift&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + shift + F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全工程搜索某字符串内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;生成构造方法或者getter/setter&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>公司巨变</title>
   <link href="http://changer119.github.io/2015/07/02/%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A8%E5%8F%98"/>
   <updated>2015-07-02T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/07/02/公司的巨变</id>
   <content type="html">&lt;p&gt;2015年6月末到7月初，公司发生了一场巨变，很多的人员主动离职。&lt;/p&gt;

&lt;p&gt;事情的起因是6月最后一个周五，突然收到李总（总裁）的邮件，说因为产品战略与公司产生分歧，提出离职。事情一出，大家就在议论，到底是什么分歧。李总说的与公司战略不一致，其实就是说的他跟CEO的意见不一致。过了大约一个小时，人力资源的负责人立马发邮件通知大家，说公司的某一项产品（由李总负责）将下线。邮件同时否认了一些谣言，并且提到了李总和另外一位核心员工的离职。&lt;/p&gt;

&lt;p&gt;本以为事情到此为止，谁知道接下来的周一，公司很多人集体离职。我猜想他们肯定都是被李总拉出去单干了。这里面有很多老员工，也有一些新进来才2-3各月的员工。他们都是按照一个团队去的，既有PM、后台、前端，还有不同业务线的人员。这些人在公司的工作交接也很神速，估计每个人只用了1-2个小时就完成交接了。等我周四从家里回到单位时，要离职的人都离开了。&lt;/p&gt;

&lt;p&gt;因为这些骨干人员的离职，CEO发邮件鼓励大家，并提及了ESOP计划，并且现在正准备开启。希望这可以团结大家吧。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Git学习</title>
   <link href="http://changer119.github.io/2015/06/24/Git%E5%AD%A6%E4%B9%A0"/>
   <updated>2015-06-24T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/06/24/Git学习</id>
   <content type="html">&lt;h2 id=&quot;pushgithub&quot;&gt;本地push更新到github&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux常用命令</title>
   <link href="http://changer119.github.io/2015/06/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"/>
   <updated>2015-06-16T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/06/16/Linux常用命令</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;查看端口使用情况&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ netstat -anp | grep 9999
&amp;gt; tcp  0  0    :::9999      :::*       LISTEN         21209/java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21209就是占用该端口应用程序的PID&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;查找文件&lt;/h3&gt;

&lt;p&gt;Linux中查找文件有以下几种方式：&lt;/p&gt;

&lt;p&gt;1， &lt;strong&gt;find命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```
find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定操作&gt;&lt;/指定操作&gt;&lt;/指定条件&gt;&lt;/指定目录&gt;&lt;/p&gt;

&lt;h1 id=&quot;my&quot;&gt;搜索当前目录下文件名以my开头的文件或者文件夹&lt;/h1&gt;
&lt;p&gt;$ find . -name ‘my&lt;em&gt;’	
# 搜索根目录（/）下文件名以my开头的文件或者文件夹，并显示详细信息
$ find / -name ‘my&lt;/em&gt;’ -al
```&lt;/p&gt;

&lt;p&gt;2， &lt;strong&gt;locate命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用&lt;strong&gt;updatedb&lt;/strong&gt;命令，手动更新数据库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
# 搜索/etc/目录下以sh开头的文件
$ locate /etc/sh*
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3， &lt;strong&gt;which命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在linux系统中，一个命令（如&lt;strong&gt;ls&lt;/strong&gt;）可能对应多个可执行的文件。用户在终端中输入命令时，linux系统究竟用的是/bin/下面的命令还是/local/bin下面的？&lt;/p&gt;

&lt;p&gt;这时就可以用which命令。它会查找$PATH变量，遇到第一个匹配的命令就返回。这第一个命令也就是系统默认调用的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ which grep
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4， &lt;strong&gt;whereis命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ whereis grep
&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>测试服务器发版备忘</title>
   <link href="http://changer119.github.io/2015/06/12/%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E7%89%88%E5%A4%87%E5%BF%98"/>
   <updated>2015-06-12T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/06/12/测试服务器发版备忘</id>
   <content type="html">&lt;h2 id=&quot;nginx&quot;&gt;配置nginx&lt;/h2&gt;
&lt;p&gt;53服务器上nigix配置文件&lt;code&gt;/etc/nginx/conf.d/default.conf&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;配置前端的代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
    # 增加前端静态文件的访问路径
    location /zydmanagec {
        #root   /usr/share/nginx/html;
        alias   /enniu/www/web-audit-static-collection/build;
        index  index.html index.htm;
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浏览器请求&lt;code&gt;192.168.2.53/zydmanagec&lt;/code&gt;时，会自动将请求路由到&lt;code&gt;/enniu/www/web-audit-static-collection/build&lt;/code&gt;路径下。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置后端的代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
    # 增加后端的路由代理
    location /zydservicec/web-audit {
        proxy_pass  http://192.168.2.53:9999/web-audit;
        #Proxy Settings
        proxy_cookie_path /web-audit/ /;
        proxy_set_header   Host   $host;
        proxy_set_header   Referer $http_referer;
        proxy_set_header   Cookie $http_cookie;
        proxy_set_header   X-Real-IP  $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用户在点击前端的按钮后，会请求后端的业务逻辑，请求的路径会变为&lt;code&gt;192.168.2.53/zydservice/web-audit&lt;/code&gt;，nginx会将该url路由到&lt;code&gt;http://192.168.2.53:9999/web-audit&lt;/code&gt;路径下，后端进行业务逻辑处理。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;让配置生效&lt;/h3&gt;
&lt;p&gt;让配置生效有两种方式：&lt;/p&gt;

&lt;h4 id=&quot;nginx-1&quot;&gt;1，重启nginx&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;
$ sudo service nginx restart
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;2，重新加载配置文件（推荐）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;
$ sudo service nginx reload
&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Linux下安装多个tomcat实例</title>
   <link href="http://changer119.github.io/2015/06/12/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AAtomcat%E5%AE%9E%E4%BE%8B"/>
   <updated>2015-06-12T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/06/12/Linux下安装多个tomcat实例</id>
   <content type="html">&lt;h2 id=&quot;tomcat&quot;&gt;拷贝tomcat目录&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;
$ cp /..../tomcat  /..../tomcat_new
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;修改配置&lt;/h2&gt;

&lt;h3 id=&quot;etcprofile&quot;&gt;修改&lt;code&gt;/etc/profile&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
# 在文件的末尾加上下面这一段
# added by fcjiang @2015-06-12 for tomcat-7-9999-test
CATALINA_3_BASE=/enniu/tomcat-7-9999-test
CATALINA_3_HOME=/enniu/tomcat-7-9999-test
TOMCAT_3_HOME=/enniu/tomcat-7-9999-test
export CATALINA_3_BASE CATALINA_3_HOME TOMCAT_3_HOME
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;etcprofile-1&quot;&gt;激活&lt;code&gt;/etc/profile&lt;/code&gt;修改内容&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ source /etc/profile
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcatnewbincatalinash&quot;&gt;修改&lt;code&gt;.../tomcat_new/bin/catalina.sh&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
# 在该文件的最前面添加一下内容
# added by fcjiang @2015-06-12 for tomcat-7-9999-test
export JAVA_HOME=$JAVA_HOME
export PATH=$PATH
export CLASSPATH=$CLASSPATH
export CATALINA_BASE=$CATALINA_3_BASE
export CATALINA_HOME=$CATALINA_3_HOME
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcatnewserverxml&quot;&gt;修改tomcat_new中server.xml文件&lt;/h3&gt;
&lt;p&gt;文件路径&lt;code&gt;.../tomcat_new/conf/server.xml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要修改三个地方：&lt;/p&gt;

&lt;p&gt;1，修改应用访问端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;connector port=&quot;9999（修改）&quot; protocol=&quot;HTTP/1.1&quot; connectiontimeout=&quot;20000&quot; redirectport=&quot;8443&quot; uriencoding=&quot;UTF-8&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;2，修改AJP端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;connector port=&quot;9009（修改）&quot; protocol=&quot;AJP/1.3&quot; redirectport=&quot;8443&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;3，修改tomcat关闭端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;server port=&quot;9005（修改）&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
```

**至此，新加的tomcat的配置已经完成**


## 启动新的tomcat

```
$ .../tomcat_new/bin/catalina.sh start
```


&lt;/server&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis入门</title>
   <link href="http://changer119.github.io/2015/06/11/Redis%E5%85%A5%E9%97%A8"/>
   <updated>2015-06-11T00:00:00+08:00</updated>
   <id>http://changer119.github.io/2015/06/11/Redis入门</id>
   <content type="html">&lt;h2 id=&quot;redis&quot;&gt;安装redis&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://yijiebuyi.com/blog/d8ab4b444c16f42cefe30df738a42518.html&quot;&gt;链接 亲测可用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;redis-1&quot;&gt;启动redis&lt;/h2&gt;
&lt;p&gt;### 启动redis服务器
&lt;code&gt;
$ /usr/local/bin/redis-server /etc/redis.conf
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上命令，表示参照配置文件&lt;code&gt;/etc/redis.conf&lt;/code&gt;启动redis服务器。配置文件中会设置redis持久化文件存放的路径（本机放在&lt;code&gt;/opt/redis/&lt;/code&gt;中）。&lt;/p&gt;

&lt;h3 id=&quot;redis-2&quot;&gt;利用客户端连接redis服务器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ /usr/local/bin/redis-cli
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上命令是连接localhost中得redis服务器（并且端口是默认的&lt;code&gt;6379&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;如果需要连接远程主机上的redis服务器，并且服务器端口不是默认的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ /usr/local/bin/redis-cli -h 192.168.1.100 -p 6388
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;断开客户端&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ quit
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;redis-3&quot;&gt;命令行使用redis&lt;/h2&gt;

&lt;h2 id=&quot;javaredis&quot;&gt;java程序使用redis&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>跨域常用的方式以及原理</title>
   <link href="http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86"/>
   <updated>2015-03-24T00:00:00+08:00</updated>
   <id>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/跨域常用的方式以及原理</id>
   <content type="html">&lt;p&gt;这篇文章紧接上一篇“&lt;a href=&quot;http://changer119.cn/fcjiang/?p=109&quot;&gt;ajax跨域访问&lt;/a&gt;”。这里主要罗列下跨域常用的方式以及跨域的原理。&lt;/p&gt;

&lt;h2 id=&quot;script&quot;&gt;使用script的方式&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;实现一&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
function jsonpCallback(result) {  
//alert(result);  
for(var i in result) {  
alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
}  
}  
var JSONP=document.createElement(&quot;script&quot;);  
JSONP.type=&quot;text/javascript&quot;;  
JSONP.src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;  
document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);  
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实现二&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    function jsonpCallback(result) {  
        alert(result.a);  
        alert(result.b);  
        alert(result.c);  
        for(var i in result) {  
            alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
        }  
    }  
&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;使用jQuery的方式&lt;/h2&gt;

&lt;h3 id=&quot;getjson&quot;&gt;实现一：$.getJSON&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $.getJSON(&quot;http://crossdomain.com/services.php?callback=?&quot;,  
    function(result) {  
        for(var i in result) {  
            alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
        }  
    });  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ajax&quot;&gt;实现二：$.ajax&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $.ajax({  
        url:&quot;http://crossdomain.com/services.php&quot;,  
        dataType:&#39;jsonp&#39;,  
        data:&#39;&#39;,  
        jsonp:&#39;callback&#39;,  
        success:function(result) {  
            for(var i in result) {  
                alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
            }  
        },  
        timeout:3000  
    });  
&amp;lt;/script&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;get&quot;&gt;实现三：$.get&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $.get(&#39;http://crossdomain.com/services.php?callback=?&#39;, {name: encodeURIComponent(&#39;tester&#39;)}, function (json) { for(var i in json) alert(i+&quot;:&quot;+json[i]); }, &#39;jsonp&#39;);  
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 jsonCallback 是客户端注册的，获取 跨域服务器 上的json数据 后，回调的函数。&lt;/p&gt;

&lt;h2 id=&quot;jsonp&quot;&gt;JSONP的原理&lt;/h2&gt;

&lt;p&gt;1，首先在客户端注册一个callback, 然后把callback的名字传给服务器。&lt;/p&gt;

&lt;p&gt;2，服务器先生成 json 数据。&lt;/p&gt;

&lt;p&gt;3，服务器端将生成的json数据作为入参，放置到callback的回调函数名中。这样就生成了一段js语法的文档，返回给客户端。&lt;/p&gt;

&lt;p&gt;4，客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>ajax跨域访问</title>
   <link href="http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/ajax%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE"/>
   <updated>2015-03-24T00:00:00+08:00</updated>
   <id>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/ajax跨域访问</id>
   <content type="html">&lt;p&gt;ajax跨域访理解起来有点绕，网上能够搜到很多相关的帖子，但基本上都是抄至同一个人。 鉴于这个原因，我自己整理一下ajax跨域访问的实例，希望帮助到更多人。&lt;/p&gt;

&lt;p&gt;我在本地有一个Java Web的应用，它需要访问远程主机（新浪SAE）的某个应用中的action。利用普通的ajax交互。&lt;/p&gt;

&lt;p&gt;本地应用中ajax请求的代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/1.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/1.png&quot; alt=&quot;1&quot; width=&quot;878&quot; height=&quot;196&quot; class=&quot;alignnone size-full wp-image-110&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;运行后得到错误提示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/2.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/2.png&quot; alt=&quot;2&quot; width=&quot;875&quot; height=&quot;130&quot; class=&quot;alignnone size-full wp-image-111&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由上可知，通过普通的ajax来获取远程主机的数据（跨域访问）是不行的。&lt;/p&gt;

&lt;p&gt;怎么样才能实现ajax的跨域访问呢？利用JSONP来进行ajax交互。具体JSONP是什么东西，大家可以google一下，略去。&lt;/p&gt;

&lt;p&gt;下面介绍如何利用JSONP进行跨域访问。 本地应用中ajax请求代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/3.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/3.png&quot; alt=&quot;3&quot; width=&quot;810&quot; height=&quot;240&quot; class=&quot;alignnone size-full wp-image-112&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/4.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/4.png&quot; alt=&quot;4&quot; width=&quot;1272&quot; height=&quot;267&quot; class=&quot;alignnone size-full wp-image-113&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当然，要实现ajax跨域仅仅在客户端改用JSONP还是不行的，必须要远程主机上的action配合才行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;远程主机action的代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/5.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/5.png&quot; alt=&quot;5&quot; width=&quot;884&quot; height=&quot;383&quot; class=&quot;alignnone size-full wp-image-114&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;客户端在拿到ajax返回的数据如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/6.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/6.png&quot; alt=&quot;6&quot; width=&quot;803&quot; height=&quot;121&quot; class=&quot;alignnone size-full wp-image-115&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;客户端jsonp的回调函数如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/7.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/7.png&quot; alt=&quot;7&quot; width=&quot;606&quot; height=&quot;63&quot; class=&quot;alignnone size-full wp-image-116&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【注】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;经我实测，在客户端中不定义jsonpCallbackFunc方法，跨域也能够成功。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跨域获得的数据能够自动传入ajax的success:function(data){}回调函数，data就是跨域所得数据。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>使用快盘同步</title>
   <link href="http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2015/03/13/%E4%BD%BF%E7%94%A8%E5%BF%AB%E7%9B%98%E5%90%8C%E6%AD%A5"/>
   <updated>2015-03-13T00:00:00+08:00</updated>
   <id>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2015/03/13/使用快盘同步</id>
   <content type="html">&lt;p&gt;我算一个深度的Dropbox用户，从2009年就开始使用，特别是工作后经常的单位和家两地切换，Dropbox就使用的更加频繁了。有了Dropbox后，我就抛掉了U盘，文件图片之类的全部通过Dropbox同步搞定。大概从2014年11-2月开始Dropbox被GFW墙掉了，Dropbox一直提示“SSL连接出错”。有时候好不容易连接上了，同步了一两个文件后又抽疯，后面就直接罢工了。刚开始碰到这种情况时，我花了九牛二虎之力去网上搜解决方案。修改Host、配置代理，我都试过了，Dropbox依然处在大洋彼岸，而我始终连接不上。没有了Dropbox，同步文件非常的不方便，但又不愿意使用115网盘，就这样忍受着。&lt;/p&gt;

&lt;p&gt;今天，因为要在单位和家里同时修改一份简历的缘故。我又想起了Dropbox，但天朝依然没有将其解封。无奈之下，我搜索“Dropbox 替代”，在知乎找到了有关讨论&lt;a href=&quot;http://www.zhihu.com/question/19647014&quot;&gt;点击跳转&lt;/a&gt;。大致浏览一遍后我选择了“金山快盘”。注册快盘后，在登录Web端时，居然出现了错误，刷新后才看到内容。看来快盘自己还有待改进。安装PC端的同步客户端后，它在本地建立了一个主目录，里面存放要同步的文件。简单那试用后，发现快盘做的还不错。基本功能上，已经做得和Dropbox类似了，右侧还会弹出一个panel，用户显示同步的相关信息。&lt;/p&gt;

&lt;p&gt;以后就会用快盘替代Dropbox。&lt;/p&gt;

&lt;p&gt;【注】中国的互联网用户好痛苦，先是用国外最好的服务，后因为GFW，总要切换到国内的山寨产品上来。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>
