<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>烂笔头</title>
        <description>烂笔头 - fcjiang</description>
        <link>http://changer119.github.io</link>
        <atom:link href="http://changer119.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Fri, 17 Jul 2015 16:33:37 +0800</lastBuildDate>
        <pubDate>Fri, 17 Jul 2015 16:33:37 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>Spring @Transactional事务管理</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;事务是什么？&lt;/h3&gt;

&lt;h3 id=&quot;spring&quot;&gt;Spring的事务管理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring的事务管理由注解@Transactional实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既可以在类上添加@Transactional，也可以在方法上添加@Transactional。在类前加上@Transactional，声明这个类的所有方法都需要事务管理，每一个业务方法开始时都会打开一个事务。在方法前添加@Transactional，表示这一个方法需要进行事务管理。&lt;/p&gt;

&lt;p&gt;Spring默认情况下会对运行期异常(RunTimeException)进行事务回滚，Unchecked Exception异常除外。&lt;/p&gt;

&lt;p&gt;如何改变默认规则：&lt;/p&gt;

&lt;p&gt;1 让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class)&lt;/p&gt;

&lt;p&gt;2 让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)&lt;/p&gt;

&lt;p&gt;3 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED)&lt;/p&gt;

&lt;p&gt;在整个方法运行前就不会开启事务&lt;/p&gt;

&lt;p&gt;单独使用 @Transactional 注释时，事务传播模式被设置成什么呢？只读标志被设置成什么呢？事务隔离级别的设置是怎样的？更重要的是，事务应何时回滚工作？理解如何使用这个注释对于确保在应用程序中获得合适的事务支持级别非常重要。回答我刚才提出的问题：在单独使用不带任何参数的 @Transactional 注释时，传播模式要设置为 REQUIRED，只读标志设置为 false，事务隔离级别设置为 READ_COMMITTED，而且事务不会针对受控异常（checked exception）回滚。&lt;/p&gt;

&lt;h3 id=&quot;transactional&quot;&gt;@Transactional的事务传递&lt;/h3&gt;
&lt;p&gt;id	|	amount
—————-| —————
1 |   1000&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;问题是什么&lt;/h2&gt;

&lt;p&gt;假设有一张表T_ACCOUNT，它的字段如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有两个线程：A和B。A需要给id=1的用户增加300元，而B需要给id=1的记录减掉100元。 可能的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithId(int id, int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果A先执行，B后执行，最后的amount的值为1200。如果B先执行，A后执行，最后的结果也是1200.最担心的情况的是，A和B同时执行。A、B两个线程同时读取到当前的值（1000），每个线程会将这个数据保存在自身的栈里。然后，A、B会竞争去做update操作，数据库引擎会保证同一时刻只有一个线程在update。如果A先做了update操作，DB中的amount会变成1300。这时B再做update，由于B已经将amount的值保留在栈内了（值为之前取到的1000），update之后，amount会变为900. 这明显不符合逻辑，多并发引起了数据的不一致。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何解决&lt;/h2&gt;

&lt;h3 id=&quot;versionid&quot;&gt;方式1（利用versionId）&lt;/h3&gt;

&lt;p&gt;在设计表的时候，多预留一个字段为version_id。它是一个普通的int类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
      &lt;th&gt;version_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在定义方法的时候，要增加一个versionId进去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithIdAndVersionId(int id, int versionId,int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当A、B同时执行。A和B先查询记录，发现id=1，versionId=1，并将结果保存在自己的栈内。当执行update操作时，总会有一个先执行。假设A先执行，A在调用updateWithIdAndVersionId方法时，程序需要&lt;strong&gt;将versionId加1&lt;/strong&gt;，这样一来，DB中id=1的记录的version_id就是2了。当B再执行updateWithIdAndVersionId操作，它根据2个条件（id=1、versionId=1）去更新。因为此时DB中已不存在这条记录了，所以更新失败。通过这种方法就可以保证多并发对数据操作的一致性。&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/07/15/Spring%20@Transactional%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86</link>
                <guid>http://changer119.github.io/2015/07/15/Spring @Transactional事务管理</guid>
                <pubDate>Wed, 15 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>多并发下的DB更新</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;问题是什么&lt;/h2&gt;

&lt;p&gt;假设有一张表T_ACCOUNT，它的字段如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有两个线程：A和B。A需要给id=1的用户增加300元，而B需要给id=1的记录减掉100元。 可能的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithId(int id, int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果A先执行，B后执行，最后的amount的值为1200。如果B先执行，A后执行，最后的结果也是1200.最担心的情况的是，A和B同时执行。A、B两个线程同时读取到当前的值（1000），每个线程会将这个数据保存在自身的栈里。然后，A、B会竞争去做update操作，数据库引擎会保证同一时刻只有一个线程在update。如果A先做了update操作，DB中的amount会变成1300。这时B再做update，由于B已经将amount的值保留在栈内了（值为之前取到的1000），update之后，amount会变为900. 这明显不符合逻辑，多并发引起了数据的不一致。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何解决&lt;/h2&gt;

&lt;h3 id=&quot;versionid&quot;&gt;方式1（利用versionId）&lt;/h3&gt;

&lt;p&gt;在设计表的时候，多预留一个字段为version_id。它是一个普通的int类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
      &lt;th&gt;version_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在定义方法的时候，要增加一个versionId进去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithIdAndVersionId(int id, int versionId,int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当A、B同时执行。A和B先查询记录，发现id=1，versionId=1，并将结果保存在自己的栈内。当执行update操作时，总会有一个先执行。假设A先执行，A在调用updateWithIdAndVersionId方法时，程序需要&lt;strong&gt;将versionId加1&lt;/strong&gt;，这样一来，DB中id=1的记录的version_id就是2了。当B再执行updateWithIdAndVersionId操作，它根据2个条件（id=1、versionId=1）去更新。因为此时DB中已不存在这条记录了，所以更新失败。通过这种方法就可以保证多并发对数据操作的一致性。&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/07/14/%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84DB%E6%9B%B4%E6%96%B0</link>
                <guid>http://changer119.github.io/2015/07/14/多并发下的DB更新</guid>
                <pubDate>Tue, 14 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>jekyll bootstrap主题安装</title>
                <description>&lt;p&gt;在安装bootsrap dinky主题后，本地运行jekyll是没问题的，但一上传到github.com后，就会报下面的错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The page build failed with the following error:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The submodule &lt;code&gt;_theme_packages/dinky&lt;/code&gt; was not properly initialized with a &lt;code&gt;.gitmodules&lt;/code&gt; file. For more information, see https://help.github.com/articles/page-build-failed-missing-submodule.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you have any questions you can contact us by replying to this email.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;笔者也很有耐心的去看了上文中的链接，结果怎么试都不行，后来在网上也找了很多其他的教程，依然解决不了。直到看到下面这两篇文章（&lt;a href=&quot;http://theloverz.me/note/2013/12/06/fix-failure-on-github-pages-and-jekyll/&quot;&gt;文章1&lt;/a&gt;，&lt;a href=&quot;http://dsimidzija.github.io/programming/2014/02/15/jekyll-bootstrap-themes-and-github-pages/&quot;&gt;文章2&lt;/a&gt;），才解决了问题。&lt;/p&gt;

&lt;p&gt;下面我介绍下我的步骤。&lt;/p&gt;

&lt;p&gt;1，进入博客的主目录(我的是changer119.github.io)，在.gitignore文件中添加如下内容。如果主目录下没有.gitignore文件，自己新增一个即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*.swp
_site/*
_theme_packages/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上内容表示，_site和 _theme_package两个目录都不加到git，也不上传到github。&lt;/p&gt;

&lt;p&gt;2，在主目录下删除已有的_theme_packages内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rm -r --cached _theme_packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, 重新安装jekyll bootstrap的主题。&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-theming.html#toc_3&quot;&gt;官方链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我使用的dinky主题，我在主目录下输入如下命令，碰到需要选择的时候，一直yes下去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rake theme:install git=&quot;git://github.com/sodabrew/theme-dinky.git&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，本地run一下jekyll，看看效果。在主目录下执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5，查看效果，访问&lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6，如果效果正常，就可以提交修改到github啦。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add *
git commit -m &#39;your log&#39;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://changer119.github.io/2015/07/08/jekyll-bootstrap-%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85</link>
                <guid>http://changer119.github.io/2015/07/08/jekyll-bootstrap-主题安装</guid>
                <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>maven入门</title>
                <description>&lt;h2 id=&quot;maven&quot;&gt;maven主要命令&lt;/h2&gt;

&lt;h3 id=&quot;test&quot;&gt;安装但不运行test代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Dmaven.test.skip=true
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;profile&quot;&gt;指定profile安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pint	# 给测试发的版本
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pdev	# 给开发发的版本
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;profiletest&quot;&gt;指定profile，不运行test（合并）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pint -Dmaven.test.skip=true
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven-1&quot;&gt;maven聚合&lt;/h2&gt;
&lt;p&gt;假设有projectA，它里面聚合了projectB、projectC两个模块，projectA的pom.xml中的&lt;code&gt;&amp;lt;packaging&amp;gt;&lt;/code&gt;属性值必须为pom。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1 id=&quot;maven-2&quot;&gt;Maven参数配置&lt;/h1&gt;

&lt;h2 id=&quot;packaging-&quot;&gt;packaging 打包类型&lt;/h2&gt;

&lt;p&gt;任何一个maven工程，对应有一个pom.xml文件。这个pom.xml文件通过&lt;code&gt;&amp;lt;packaging&amp;gt;xxx&amp;lt;/packaging&amp;gt;&lt;/code&gt;来决定该工程打包的类型（打成jar包？war包？）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不填时（默认），表示打成jar包。&lt;/li&gt;
  &lt;li&gt;war，表示打成war包。&lt;/li&gt;
  &lt;li&gt;pom，表示这个工程不打包，它是其它工程的父工程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;nexus&quot;&gt;Nexus相关&lt;/h1&gt;

&lt;p&gt;Nexus安装之后，会自动配置下面这几个仓库。如图：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图片&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;这里面的仓库主要有三种类型： &lt;code&gt;hosted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;proxy&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;group&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;hosted&lt;/strong&gt;: 主要与公司内部打交道。例如用户发布包（&lt;code&gt;mvn deploy&lt;/code&gt;）就会将包上传到&lt;code&gt;hosted&lt;/code&gt;类别的仓库中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Releases仓库：当工程pom的version为x.x.x-Release时，用户发布后会将包上传到该仓库。&lt;/li&gt;
  &lt;li&gt;Snapshots仓库：与上逻辑同。&lt;/li&gt;
  &lt;li&gt;3rd part仓库：如果有些依赖包在maven的中央仓库找不到，就需要到该依赖包的官网下载，让后将依赖包上传到该仓库中。用户下次添加依赖时，会直接到该仓库获取。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;proxy&lt;/strong&gt;: 主要与外网打交道。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Centeral仓库：从maven中央仓库下载的包都放在该仓库。&lt;/li&gt;
  &lt;li&gt;Apache Snapshots仓库：放从apache下载的包。&lt;/li&gt;
  &lt;li&gt;Codehause Snapshots仓库：放从codehause下载的包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;设置mirror后，工程只会访问镜像，如果程序访问不了镜像，也不会去访问中央工厂回到家后，无法访问mirror时，就需要注释mirror，程序才会去中央工厂下载&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;mvn-deploy&quot;&gt;发布（mvn deploy）&lt;/h2&gt;

&lt;p&gt;要将包发布到私服上，需要先在pom中设置&lt;code&gt;&amp;lt;distributionManagement&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;server&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图片1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pic2&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven-3&quot;&gt;Maven的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;有3套生命周期：clean的生命周期、compile的生命周期、site的生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下图列出了执行mvn clean和mvn install需要完成的步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-2@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-3@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件的配置&lt;/h2&gt;

&lt;p&gt;表示在执行完validate之后，就会执行jar和test-jar操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-4@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;**在父级pom中，有&lt;code&gt;&amp;lt;pluginsManagement&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;标签，在它里面定义的内容不能够被子模块直接继承，需要在子模块中手动添加groupid和archtypeId才行**&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
                <link>http://changer119.github.io/2015/07/08/Maven%E5%85%A5%E9%97%A8</link>
                <guid>http://changer119.github.io/2015/07/08/Maven入门</guid>
                <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>测试图片显示</title>
                <description>
&lt;p&gt;这是一张图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.github.io/assets/images/1.jpg&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://changer119.github.io/2015/07/07/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87</link>
                <guid>http://changer119.github.io/2015/07/07/测试使用图片</guid>
                <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>java枚举类型初体验</title>
                <description>&lt;p&gt;Enum是JDK5引入的。有了Enum类型后，对于常量的处理更加方便。&lt;/p&gt;

&lt;p&gt;以前定义常量一般是这样的：&lt;/p&gt;

&lt;p&gt;```
Constant.java&lt;/p&gt;

&lt;p&gt;public interface Constant{
	public final PI = 3.14;
	public fianl G = 9.8;
}
```&lt;/p&gt;

&lt;p&gt;以前这些常量可能分散在不同的文件中，缺乏统一的管理，使用不方便。&lt;/p&gt;

&lt;p&gt;利用Enum类型，可以将常量定义成如下形式：&lt;/p&gt;

&lt;p&gt;```
ColorEnum.java&lt;/p&gt;

&lt;p&gt;public enum ColorEnum{
	RED, GREEN, YELLOW;
}
```&lt;/p&gt;

&lt;p&gt;如果觉得上面的枚举太过简单，可以给ColorEnum添加方法。&lt;/p&gt;

&lt;p&gt;```
public enum Color {
    // 必须先定义枚举类Color的实例
    Red(1, “红色”),
    Green(2, “绿色”),
    Yellow(3, “黄色”),
    Pink(4, “粉红色”);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final int id;
private final String description;


// 根据id值得到对应的description
public static String getDescription(int id){
    for(Color item : Color.values()){
        if(item.getId() == id){
            return item.getDescription();
        }
    }
    return null;
}
// 根据id值得到对应的枚举实例
public static Color getColor(int id){
    for(Color item : Color.values()){
        if(item.getId() == id){
            return item;
        }
    }
    return null;
}
// 根据id值得到对应的枚举实例
public static Color valueOf(int id){
    switch (id){
        case 1:
            return Color.Red;
        case 2:
            return Color.Green;
        case 3:
            return Color.Yellow;
        case 4:
            return Color.Pink;
        default:
            return  null;
    }
}

//覆盖方法
@Override
public String toString() {
    return this.id+&quot;_&quot; + this.description;
}

Color(int id, String description) {
    this.id = id;
    this.description = description;
}

public int getId() {
    return id;
}

public String getDescription() {
    return description;
}

// 枚举类里面可以添加main方法
public static void main(String[] args){
    int id = 2;
    Color c = Color.getColor(2);
    System.out.println(c);
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义枚举类时，枚举实例必须放在最前面，并且已&lt;code&gt;;&lt;/code&gt;分号隔开。&lt;/li&gt;
  &lt;li&gt;枚举实例&lt;code&gt;Red(1, &quot;红色&quot;)&lt;/code&gt;，是根据枚举类的定义得来的。（枚举类有id, description两个成员变量）&lt;/li&gt;
  &lt;li&gt;这种枚举类主要用在数据库的状态字段中。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://changer119.github.io/2015/07/07/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8</link>
                <guid>http://changer119.github.io/2015/07/07/Java枚举类型使用</guid>
                <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Intellij入门</title>
                <description>&lt;h2 id=&quot;svnmaven&quot;&gt;导出svn上的maven工程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;ld&lt;/li&gt;
  &lt;li&gt;代码checkout到本地后，查看代码发现都有红色的问号（表示有错误）。这是因为Intellij没有自动刷新导致的。只要点击Intellij右侧MavenProjects，再点击刷新图标即可。
&lt;img src=&quot;../_images/QQ20150707-1@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;intellij&quot;&gt;Intellij常用快捷键&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;组合键&lt;/th&gt;
      &lt;th&gt;实现的功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;替换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;alt + F7&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找方法或者类被引用的地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + shift + F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全工程搜索某字符串内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;生成构造方法或者getter/setter&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
                <link>http://changer119.github.io/2015/07/07/Intellij%E4%BD%BF%E7%94%A8</link>
                <guid>http://changer119.github.io/2015/07/07/Intellij使用</guid>
                <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>公司巨变</title>
                <description>&lt;p&gt;2015年6月末到7月初，公司发生了一场巨变，很多的人员主动离职。&lt;/p&gt;

&lt;p&gt;事情的起因是6月最后一个周五，突然收到李总（总裁）的邮件，说因为产品战略与公司产生分歧，提出离职。事情一出，大家就在议论，到底是什么分歧。李总说的与公司战略不一致，其实就是说的他跟CEO的意见不一致。过了大约一个小时，人力资源的负责人立马发邮件通知大家，说公司的某一项产品（由李总负责）将下线。邮件同时否认了一些谣言，并且提到了李总和另外一位核心员工的离职。&lt;/p&gt;

&lt;p&gt;本以为事情到此为止，谁知道接下来的周一，公司很多人集体离职。我猜想他们肯定都是被李总拉出去单干了。这里面有很多老员工，也有一些新进来才2-3各月的员工。他们都是按照一个团队去的，既有PM、后台、前端，还有不同业务线的人员。这些人在公司的工作交接也很神速，估计每个人只用了1-2个小时就完成交接了。等我周四从家里回到单位时，要离职的人都离开了。&lt;/p&gt;

&lt;p&gt;因为这些骨干人员的离职，CEO发邮件鼓励大家，并提及了ESOP计划，并且现在正准备开启。希望这可以团结大家吧。&lt;/p&gt;
</description>
                <link>http://changer119.github.io/2015/07/02/%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A8%E5%8F%98</link>
                <guid>http://changer119.github.io/2015/07/02/公司的巨变</guid>
                <pubDate>Thu, 02 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Git学习</title>
                <description>&lt;h2 id=&quot;pushgithub&quot;&gt;本地push更新到github&lt;/h2&gt;
</description>
                <link>http://changer119.github.io/2015/06/24/Git%E5%AD%A6%E4%B9%A0</link>
                <guid>http://changer119.github.io/2015/06/24/Git学习</guid>
                <pubDate>Wed, 24 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Linux常用命令</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;查看端口使用情况&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ netstat -anp | grep 9999
&amp;gt; tcp  0  0    :::9999      :::*       LISTEN         21209/java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21209就是占用该端口应用程序的PID&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;查找文件&lt;/h3&gt;

&lt;p&gt;Linux中查找文件有以下几种方式：&lt;/p&gt;

&lt;p&gt;1， &lt;strong&gt;find命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```
find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定操作&gt;&lt;/指定操作&gt;&lt;/指定条件&gt;&lt;/指定目录&gt;&lt;/p&gt;

&lt;h1 id=&quot;my&quot;&gt;搜索当前目录下文件名以my开头的文件或者文件夹&lt;/h1&gt;
&lt;p&gt;$ find . -name ‘my&lt;em&gt;’	
# 搜索根目录（/）下文件名以my开头的文件或者文件夹，并显示详细信息
$ find / -name ‘my&lt;/em&gt;’ -al
```&lt;/p&gt;

&lt;p&gt;2， &lt;strong&gt;locate命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用&lt;strong&gt;updatedb&lt;/strong&gt;命令，手动更新数据库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
# 搜索/etc/目录下以sh开头的文件
$ locate /etc/sh*
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3， &lt;strong&gt;which命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在linux系统中，一个命令（如&lt;strong&gt;ls&lt;/strong&gt;）可能对应多个可执行的文件。用户在终端中输入命令时，linux系统究竟用的是/bin/下面的命令还是/local/bin下面的？&lt;/p&gt;

&lt;p&gt;这时就可以用which命令。它会查找$PATH变量，遇到第一个匹配的命令就返回。这第一个命令也就是系统默认调用的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ which grep
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4， &lt;strong&gt;whereis命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ whereis grep
&lt;/code&gt;&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/06/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</link>
                <guid>http://changer119.github.io/2015/06/16/Linux常用命令</guid>
                <pubDate>Tue, 16 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>测试服务器发版备忘</title>
                <description>&lt;h2 id=&quot;nginx&quot;&gt;配置nginx&lt;/h2&gt;
&lt;p&gt;53服务器上nigix配置文件&lt;code&gt;/etc/nginx/conf.d/default.conf&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;配置前端的代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
    # 增加前端静态文件的访问路径
    location /zydmanagec {
        #root   /usr/share/nginx/html;
        alias   /enniu/www/web-audit-static-collection/build;
        index  index.html index.htm;
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浏览器请求&lt;code&gt;192.168.2.53/zydmanagec&lt;/code&gt;时，会自动将请求路由到&lt;code&gt;/enniu/www/web-audit-static-collection/build&lt;/code&gt;路径下。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置后端的代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
    # 增加后端的路由代理
    location /zydservicec/web-audit {
        proxy_pass  http://192.168.2.53:9999/web-audit;
        #Proxy Settings
        proxy_cookie_path /web-audit/ /;
        proxy_set_header   Host   $host;
        proxy_set_header   Referer $http_referer;
        proxy_set_header   Cookie $http_cookie;
        proxy_set_header   X-Real-IP  $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用户在点击前端的按钮后，会请求后端的业务逻辑，请求的路径会变为&lt;code&gt;192.168.2.53/zydservice/web-audit&lt;/code&gt;，nginx会将该url路由到&lt;code&gt;http://192.168.2.53:9999/web-audit&lt;/code&gt;路径下，后端进行业务逻辑处理。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;让配置生效&lt;/h3&gt;
&lt;p&gt;让配置生效有两种方式：&lt;/p&gt;

&lt;h4 id=&quot;nginx-1&quot;&gt;1，重启nginx&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;
$ sudo service nginx restart
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;2，重新加载配置文件（推荐）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;
$ sudo service nginx reload
&lt;/code&gt;&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/06/12/%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E7%89%88%E5%A4%87%E5%BF%98</link>
                <guid>http://changer119.github.io/2015/06/12/测试服务器发版备忘</guid>
                <pubDate>Fri, 12 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Linux下安装多个tomcat实例</title>
                <description>&lt;h2 id=&quot;tomcat&quot;&gt;拷贝tomcat目录&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;
$ cp /..../tomcat  /..../tomcat_new
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;修改配置&lt;/h2&gt;

&lt;h3 id=&quot;etcprofile&quot;&gt;修改&lt;code&gt;/etc/profile&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
# 在文件的末尾加上下面这一段
# added by fcjiang @2015-06-12 for tomcat-7-9999-test
CATALINA_3_BASE=/enniu/tomcat-7-9999-test
CATALINA_3_HOME=/enniu/tomcat-7-9999-test
TOMCAT_3_HOME=/enniu/tomcat-7-9999-test
export CATALINA_3_BASE CATALINA_3_HOME TOMCAT_3_HOME
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;etcprofile-1&quot;&gt;激活&lt;code&gt;/etc/profile&lt;/code&gt;修改内容&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ source /etc/profile
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcatnewbincatalinash&quot;&gt;修改&lt;code&gt;.../tomcat_new/bin/catalina.sh&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
# 在该文件的最前面添加一下内容
# added by fcjiang @2015-06-12 for tomcat-7-9999-test
export JAVA_HOME=$JAVA_HOME
export PATH=$PATH
export CLASSPATH=$CLASSPATH
export CATALINA_BASE=$CATALINA_3_BASE
export CATALINA_HOME=$CATALINA_3_HOME
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcatnewserverxml&quot;&gt;修改tomcat_new中server.xml文件&lt;/h3&gt;
&lt;p&gt;文件路径&lt;code&gt;.../tomcat_new/conf/server.xml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要修改三个地方：&lt;/p&gt;

&lt;p&gt;1，修改应用访问端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;connector port=&quot;9999（修改）&quot; protocol=&quot;HTTP/1.1&quot; connectiontimeout=&quot;20000&quot; redirectport=&quot;8443&quot; uriencoding=&quot;UTF-8&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;2，修改AJP端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;connector port=&quot;9009（修改）&quot; protocol=&quot;AJP/1.3&quot; redirectport=&quot;8443&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;3，修改tomcat关闭端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;server port=&quot;9005（修改）&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
```

**至此，新加的tomcat的配置已经完成**


## 启动新的tomcat

```
$ .../tomcat_new/bin/catalina.sh start
```


&lt;/server&gt;
</description>
                <link>http://changer119.github.io/2015/06/12/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AAtomcat%E5%AE%9E%E4%BE%8B</link>
                <guid>http://changer119.github.io/2015/06/12/Linux下安装多个tomcat实例</guid>
                <pubDate>Fri, 12 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Redis入门</title>
                <description>&lt;h2 id=&quot;redis&quot;&gt;安装redis&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://yijiebuyi.com/blog/d8ab4b444c16f42cefe30df738a42518.html&quot;&gt;链接 亲测可用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;redis-1&quot;&gt;启动redis&lt;/h2&gt;
&lt;p&gt;### 启动redis服务器
&lt;code&gt;
$ /usr/local/bin/redis-server /etc/redis.conf
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上命令，表示参照配置文件&lt;code&gt;/etc/redis.conf&lt;/code&gt;启动redis服务器。配置文件中会设置redis持久化文件存放的路径（本机放在&lt;code&gt;/opt/redis/&lt;/code&gt;中）。&lt;/p&gt;

&lt;h3 id=&quot;redis-2&quot;&gt;利用客户端连接redis服务器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ /usr/local/bin/redis-cli
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上命令是连接localhost中得redis服务器（并且端口是默认的&lt;code&gt;6379&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;如果需要连接远程主机上的redis服务器，并且服务器端口不是默认的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ /usr/local/bin/redis-cli -h 192.168.1.100 -p 6388
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;断开客户端&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ quit
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;redis-3&quot;&gt;命令行使用redis&lt;/h2&gt;

&lt;h2 id=&quot;javaredis&quot;&gt;java程序使用redis&lt;/h2&gt;
</description>
                <link>http://changer119.github.io/2015/06/11/Redis%E5%85%A5%E9%97%A8</link>
                <guid>http://changer119.github.io/2015/06/11/Redis入门</guid>
                <pubDate>Thu, 11 Jun 2015 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
