<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>烂笔头</title>
        <description>烂笔头 - fcjiang</description>
        <link>http://changer119.github.io</link>
        <atom:link href="http://changer119.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Sat, 18 Jul 2015 15:05:22 +0800</lastBuildDate>
        <pubDate>Sat, 18 Jul 2015 15:05:22 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>互联网金融监管意见发布</title>
                <description>&lt;p&gt;2015年7月18日，国家终于发布了&lt;strong&gt;互联网金融监管意见&lt;/strong&gt;。这份意见是10部委联合起草的，目前还只是框架性建议。具体的监管细节文件还在草拟中。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[全文如下]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;近年来，互联网技术、信息通信技术不断取得突破，推动互联网与金融快速融合，促进了金融创新，提高了金融资源配置效率，但也存在一些问题和风险隐患。为全面贯彻落实党的十八大和十八届二中、三中、四中全会精神，按照党中央、国务院决策部署，遵循“鼓励创新、防范风险、趋利避害、健康发展”的总体要求，从金融业健康发展全局出发，进一步推进金融改革创新和对外开放，促进互联网金融健康发展，经党中央、国务院同意，现提出以下意见。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、鼓励创新，支持互联网金融稳步发展&lt;/h3&gt;

&lt;p&gt;互联网金融是传统金融机构与互联网企业(以下统称从业机构)利用互联网技术和信息通信技术实现资金融通、支付、投资和信息中介服务的新型金融业务模式。互联网与金融深度融合是大势所趋，将对金融产品、业务、组织和服务等方面产生更加深刻的影响。互联网金融对促进小微企业发展和扩大就业发挥了现有金融机构难以替代的积极作用，为大众创业、万众创新打开了大门。促进互联网金融健康发展，有利于提升金融服务质量和效率，深化金融改革，促进金融创新发展，扩大金融业对内对外开放，构建多层次金融体系。作为新生事物，互联网金融既需要市场驱动，鼓励创新，也需要政策助力，促进发展。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(一)积极鼓励互联网金融平台、产品和服务创新，激发市场活力。&lt;/strong&gt;鼓励银行、证券、保险、基金、信托和消费金融等金融机构依托互联网技术，实现传统金融业务与服务转型升级，积极开发基于互联网技术的新产品和新服务。支持有条件的金融机构建设创新型互联网平台开展网络银行、网络证券、网络保险、网络基金销售和网络消费金融等业务。支持互联网企业依法合规设立互联网支付机构、网络借贷平台、股权众筹融资平台、网络金融产品销售平台，建立服务实体经济的多层次金融服务体系，更好地满足中小微企业和个人投融资需求，进一步拓展普惠金融的广度和深度。鼓励电子商务企业在符合金融法律法规规定的条件下自建和完善线上金融服务体系，有效拓展电商供应链业务。鼓励从业机构积极开展产品、服务、技术和管理创新，提升从业机构核心竞争力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(二)鼓励从业机构相互合作，实现优势互补。&lt;/strong&gt;支持各类金融机构与互联网企业开展合作，建立良好的互联网金融生态环境和产业链。鼓励银行业金融机构开展业务创新，为第三方支付机构和网络贷款平台等提供资金存管、支付清算等配套服务。支持小微金融服务机构与互联网企业开展业务合作，实现商业模式创新。支持证券、基金、信托、消费金融、期货机构与互联网企业开展合作，拓宽金融产品销售渠道，创新财富管理模式。鼓励保险公司与互联网企业合作，提升互联网金融企业风险抵御能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(三)拓宽从业机构融资渠道，改善融资环境。&lt;/strong&gt;支持社会资本发起设立互联网金融产业投资基金，推动从业机构与创业投资机构、产业投资基金深度合作。鼓励符合条件的优质从业机构在主板、创业板等境内资本市场上市融资。鼓励银行业金融机构按照支持小微企业发展的各项金融政策，对处于初创期的从业机构予以支持。针对互联网企业特点，创新金融产品和服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(四)坚持简政放权，提供优质服务。&lt;/strong&gt;各金融监管部门要积极支持金融机构开展互联网金融业务。按照法律法规规定，对符合条件的互联网企业开展相关金融业务实施高效管理。工商行政管理部门要支持互联网企业依法办理工商注册登记。电信主管部门、国家互联网信息管理部门要积极支持互联网金融业务，电信主管部门对互联网金融业务涉及的电信业务进行监管，国家互联网信息管理部门负责对金融信息服务、互联网信息内容等业务进行监管。积极开展互联网金融领域立法研究，适时出台相关管理规章，营造有利于互联网金融发展的良好制度环境。加大对从业机构专利、商标等知识产权的保护力度。鼓励省级人民政府加大对互联网金融的政策支持。支持设立专业化互联网金融研究机构，鼓励建设互联网金融信息交流平台，积极开展互联网金融研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(五)落实和完善有关财税政策。&lt;/strong&gt;按照税收公平原则，对于业务规模较小、处于初创期的从业机构，符合我国现行对中小企业特别是小微企业税收政策条件的，可按规定享受税收优惠政策。结合金融业营业税改征增值税改革，统筹完善互联网金融税收政策。落实从业机构新技术、新产品研发费用税前加计扣除政策。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(六)推动信用基础设施建设，培育互联网金融配套服务体系。&lt;/strong&gt;支持大数据存储、网络与信息安全维护等技术领域基础设施建设。鼓励从业机构依法建立信用信息共享平台。推动符合条件的相关从业机构接入金融信用信息基础数据库。允许有条件的从业机构依法申请征信业务许可。支持具备资质的信用中介组织开展互联网企业信用评级，增强市场信息透明度。鼓励会计、审计、法律、咨询等中介服务机构为互联网企业提供相关专业服务。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、分类指导，明确互联网金融监管责任&lt;/h3&gt;

&lt;p&gt;互联网金融本质仍属于金融，没有改变金融风险隐蔽性、传染性、广泛性和突发性的特点。加强互联网金融监管，是促进互联网金融健康发展的内在要求。同时，互联网金融是新生事物和新兴业态，要制定适度宽松的监管政策，为互联网金融创新留有余地和空间。通过鼓励创新和加强监管相互支撑，促进互联网金融健康发展，更好地服务实体经济。互联网金融监管应遵循“依法监管、适度监管、分类监管、协同监管、创新监管”的原则，科学合理界定各业态的业务边界及准入条件，落实监管责任，明确风险底线，保护合法经营，坚决打击违法和违规行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(七)  互联网支付。&lt;/strong&gt;互联网支付是指通过计算机、手机等设备，依托互联网发起支付指令、转移货币资金的服务。互联网支付应始终坚持服务电子商务发展和为社会提供小额、快捷、便民小微支付服务的宗旨。银行业金融机构和第三方支付机构从事互联网支付，应遵守现行法律法规和监管规定。第三方支付机构与其他机构开展合作的，应清晰界定各方的权利义务关系，建立有效的风险隔离机制和客户权益保障机制。要向客户充分披露服务信息，清晰地提示业务风险，不得夸大支付服务中介的性质和职能。互联网支付业务由人民银行负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(八)网络借贷。&lt;/strong&gt;网络借贷包括个体网络借贷(即P2P网络借贷)和网络小额贷款。个体网络借贷是指个体和个体之间通过互联网平台实现的直接借贷。在个体网络借贷平台上发生的直接借贷行为属于民间借贷范畴，受合同法、民法通则等法律法规以及最高人民法院相关司法解释规范。个体网络借贷要坚持平台功能，为投资方和融资方提供信息交互、撮合、资信评估等中介服务。个体网络借贷机构要明确信息中介性质，主要为借贷双方的直接借贷提供信息服务，不得提供增信服务，不得非法集资。网络小额贷款是指互联网企业通过其控制的小额贷款公司，利用互联网向客户提供的小额贷款。网络小额贷款应遵守现有小额贷款公司监管规定，发挥网络贷款优势，努力降低客户融资成本。网络借贷业务由银监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(九)股权众筹融资。&lt;/strong&gt;股权众筹融资主要是指通过互联网形式进行公开小额股权融资的活动。股权众筹融资必须通过股权众筹融资中介机构平台(互联网网站或其他类似的电子媒介)进行。股权众筹融资中介机构可以在符合法律法规规定前提下，对业务模式进行创新探索，发挥股权众筹融资作为多层次资本市场有机组成部分的作用，更好服务创新创业企业。股权众筹融资方应为小微企业，应通过股权众筹融资中介机构向投资人如实披露企业的商业模式、经营管理、财务、资金使用等关键信息，不得误导或欺诈投资者。投资者应当充分了解股权众筹融资活动风险，具备相应风险承受能力，进行小额投资。股权众筹融资业务由证监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十)互联网基金销售。&lt;/strong&gt;基金销售机构与其他机构通过互联网合作销售基金等理财产品的，要切实履行风险披露义务，不得通过违规承诺收益方式吸引客户；基金管理人应当采取有效措施防范资产配置中的期限错配和流动性风险；基金销售机构及其合作机构通过其他活动为投资人提供收益的，应当对收益构成、先决条件、适用情形等进行全面、真实、准确表述和列示，不得与基金产品收益混同。第三方支付机构在开展基金互联网销售支付服务过程中，应当遵守人民银行、证监会关于客户备付金及基金销售结算资金的相关监管要求。第三方支付机构的客户备付金只能用于办理客户委托的支付业务，不得用于垫付基金和其他理财产品的资金赎回。互联网基金销售业务由证监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十一)互联网保险。&lt;/strong&gt;保险公司开展互联网保险业务，应遵循安全性、保密性和稳定性原则，加强风险管理，完善内控系统，确保交易安全、信息安全和资金安全。专业互联网保险公司应当坚持服务互联网经济活动的基本定位，提供有针对性的保险服务。保险公司应建立对所属电子商务公司等非保险类子公司的管理制度，建立必要的防火墙。保险公司通过互联网销售保险产品，不得进行不实陈述、片面或夸大宣传过往业绩、违规承诺收益或者承担损失等误导性描述。互联网保险业务由保监会负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十二)互联网信托和互联网消费金融。&lt;/strong&gt;信托公司、消费金融公司通过互联网开展业务的，要严格遵循监管规定，加强风险管理，确保交易合法合规，并保守客户信息。信托公司通过互联网进行产品销售及开展其他信托业务的，要遵守合格投资者等监管规定，审慎甄别客户身份和评估客户风险承受能力，不能将产品销售给与风险承受能力不相匹配的客户。信托公司与消费金融公司要制定完善产品文件签署制度，保证交易过程合法合规，安全规范。互联网信托业务、互联网消费金融业务由银监会负责监管。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、健全制度，规范互联网金融市场秩序&lt;/h3&gt;

&lt;p&gt;发展互联网金融要以市场为导向，遵循服务实体经济、服从宏观调控和维护金融稳定的总体目标，切实保障消费者合法权益，维护公平竞争的市场秩序。要细化管理制度，为互联网金融健康发展营造良好环境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十三)互联网行业管理。&lt;/strong&gt;任何组织和个人开设网站从事互联网金融业务的，除应按规定履行相关金融监管程序外，还应依法向电信主管部门履行网站备案手续，否则不得开展互联网金融业务。工业和信息化部负责对互联网金融业务涉及的电信业务进行监管，国家互联网信息办公室负责对金融信息服务、互联网信息内容等业务进行监管，两部门按职责制定相关监管细则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十四)客户资金第三方存管制度。&lt;/strong&gt;除另有规定外，从业机构应当选择符合条件的银行业金融机构作为资金存管机构，对客户资金进行管理和监督，实现客户资金与从业机构自身资金分账管理。客户资金存管账户应接受独立审计并向客户公开审计结果。人民银行会同金融监管部门按照职责分工实施监管，并制定相关监管细则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十五)信息披露、风险提示和合格投资者制度。&lt;/strong&gt;从业机构应当对客户进行充分的信息披露，及时向投资者公布其经营活动和财务状况的相关信息，以便投资者充分了解从业机构运作状况，促使从业机构稳健经营和控制风险。从业机构应当向各参与方详细说明交易模式、参与方的权利和义务，并进行充分的风险提示。要研究建立互联网金融的合格投资者制度，提升投资者保护水平。有关部门按照职责分工负责监管。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十六)消费者权益保护。&lt;/strong&gt;研究制定互联网金融消费者教育规划，及时发布维权提示。加强互联网金融产品合同内容、免责条款规定等与消费者利益相关的信息披露工作，依法监督处理经营者利用合同格式条款侵害消费者合法权益的违法、违规行为。构建在线争议解决、现场接待受理、监管部门受理投诉、第三方调解以及仲裁、诉讼等多元化纠纷解决机制。细化完善互联网金融个人信息保护的原则、标准和操作流程。严禁网络销售金融产品过程中的不实宣传、强制捆绑销售。人民银行、银监会、证监会、保监会会同有关行政执法部门，根据职责分工依法开展互联网金融领域消费者和投资者权益保护工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十七)网络与信息安全。&lt;/strong&gt;从业机构应当切实提升技术安全水平，妥善保管客户资料和交易信息，不得非法买卖、泄露客户个人信息。人民银行、银监会、证监会、保监会、工业和信息化部、公安部、国家互联网信息办公室分别负责对相关从业机构的网络与信息安全保障进行监管，并制定相关监管细则和技术安全标准。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十八)反洗钱和防范金融犯罪。&lt;/strong&gt;从业机构应当采取有效措施识别客户身份，主动监测并报告可疑交易，妥善保存客户资料和交易记录。从业机构有义务按照有关规定，建立健全有关协助查询、冻结的规章制度，协助公安机关和司法机关依法、及时查询、冻结涉案财产，配合公安机关和司法机关做好取证和执行工作。坚决打击涉及非法集资等互联网金融犯罪，防范金融风险，维护金融秩序。金融机构在和互联网企业开展合作、代理时应根据有关法律和规定签订包括反洗钱和防范金融犯罪要求的合作、代理协议，并确保不因合作、代理关系而降低反洗钱和金融犯罪执行标准。人民银行牵头负责对从业机构履行反洗钱义务进行监管，并制定相关监管细则。打击互联网金融犯罪工作由公安部牵头负责。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(十九)加强互联网金融行业自律。&lt;/strong&gt;充分发挥行业自律机制在规范从业机构市场行为和保护行业合法权益等方面的积极作用。人民银行会同有关部门，组建中国互联网金融协会。协会要按业务类型，制订经营管理规则和行业标准，推动机构之间的业务交流和信息共享。协会要明确自律惩戒机制，提高行业规则和标准的约束力。强化守法、诚信、自律意识，树立从业机构服务经济社会发展的正面形象，营造诚信规范发展的良好氛围。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(二十)监管协调与数据统计监测。&lt;/strong&gt;各监管部门要相互协作、形成合力，充分发挥金融监管协调部际联席会议制度的作用。人民银行、银监会、证监会、保监会应当密切关注互联网金融业务发展及相关风险，对监管政策进行跟踪评估，适时提出调整建议，不断总结监管经验。财政部负责互联网金融从业机构财务监管政策。人民银行会同有关部门，负责建立和完善互联网金融数据统计监测体系，相关部门按照监管职责分工负责相关互联网金融数据统计和监测工作，并实现统计数据和信息共享。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[全文完]&lt;/em&gt;&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/07/18/%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D%E7%9B%91%E7%AE%A1%E6%84%8F%E8%A7%81%E5%8F%91%E5%B8%83</link>
                <guid>http://changer119.github.io/2015/07/18/互联网金融监管意见发布</guid>
                <pubDate>Sat, 18 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Spring @Transactional事务管理</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;事务是什么？&lt;/h3&gt;

&lt;h3 id=&quot;spring&quot;&gt;Spring的事务管理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring的事务管理由注解@Transactional实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既可以在类上添加@Transactional，也可以在方法上添加@Transactional。在类前加上@Transactional，声明这个类的所有方法都需要事务管理，每一个业务方法开始时都会打开一个事务。在方法前添加@Transactional，表示这一个方法需要进行事务管理。&lt;/p&gt;

&lt;p&gt;Spring默认情况下会对运行期异常(RunTimeException)进行事务回滚，Unchecked Exception异常除外。&lt;/p&gt;

&lt;p&gt;如何改变默认规则：&lt;/p&gt;

&lt;p&gt;1 让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class)&lt;/p&gt;

&lt;p&gt;2 让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)&lt;/p&gt;

&lt;p&gt;3 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED)&lt;/p&gt;

&lt;p&gt;在整个方法运行前就不会开启事务&lt;/p&gt;

&lt;p&gt;单独使用 @Transactional 注释时，事务传播模式被设置成什么呢？只读标志被设置成什么呢？事务隔离级别的设置是怎样的？更重要的是，事务应何时回滚工作？理解如何使用这个注释对于确保在应用程序中获得合适的事务支持级别非常重要。回答我刚才提出的问题：在单独使用不带任何参数的 @Transactional 注释时，传播模式要设置为 REQUIRED，只读标志设置为 false，事务隔离级别设置为 READ_COMMITTED，而且事务不会针对受控异常（checked exception）回滚。&lt;/p&gt;

&lt;h3 id=&quot;transactional&quot;&gt;@Transactional的事务传递&lt;/h3&gt;
&lt;p&gt;id	|	amount
—————-| —————
1 |   1000&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;问题是什么&lt;/h2&gt;

&lt;p&gt;假设有一张表T_ACCOUNT，它的字段如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有两个线程：A和B。A需要给id=1的用户增加300元，而B需要给id=1的记录减掉100元。 可能的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithId(int id, int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果A先执行，B后执行，最后的amount的值为1200。如果B先执行，A后执行，最后的结果也是1200.最担心的情况的是，A和B同时执行。A、B两个线程同时读取到当前的值（1000），每个线程会将这个数据保存在自身的栈里。然后，A、B会竞争去做update操作，数据库引擎会保证同一时刻只有一个线程在update。如果A先做了update操作，DB中的amount会变成1300。这时B再做update，由于B已经将amount的值保留在栈内了（值为之前取到的1000），update之后，amount会变为900. 这明显不符合逻辑，多并发引起了数据的不一致。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何解决&lt;/h2&gt;

&lt;h3 id=&quot;versionid&quot;&gt;方式1（利用versionId）&lt;/h3&gt;

&lt;p&gt;在设计表的时候，多预留一个字段为version_id。它是一个普通的int类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
      &lt;th&gt;version_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在定义方法的时候，要增加一个versionId进去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithIdAndVersionId(int id, int versionId,int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当A、B同时执行。A和B先查询记录，发现id=1，versionId=1，并将结果保存在自己的栈内。当执行update操作时，总会有一个先执行。假设A先执行，A在调用updateWithIdAndVersionId方法时，程序需要&lt;strong&gt;将versionId加1&lt;/strong&gt;，这样一来，DB中id=1的记录的version_id就是2了。当B再执行updateWithIdAndVersionId操作，它根据2个条件（id=1、versionId=1）去更新。因为此时DB中已不存在这条记录了，所以更新失败。通过这种方法就可以保证多并发对数据操作的一致性。&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/07/15/Spring%20@Transactional%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86</link>
                <guid>http://changer119.github.io/2015/07/15/Spring @Transactional事务管理</guid>
                <pubDate>Wed, 15 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>多并发下的DB更新</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;问题是什么&lt;/h2&gt;

&lt;p&gt;假设有一张表T_ACCOUNT，它的字段如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有两个线程：A和B。A需要给id=1的用户增加300元，而B需要给id=1的记录减掉100元。 可能的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithId(int id, int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果A先执行，B后执行，最后的amount的值为1200。如果B先执行，A后执行，最后的结果也是1200.最担心的情况的是，A和B同时执行。A、B两个线程同时读取到当前的值（1000），每个线程会将这个数据保存在自身的栈里。然后，A、B会竞争去做update操作，数据库引擎会保证同一时刻只有一个线程在update。如果A先做了update操作，DB中的amount会变成1300。这时B再做update，由于B已经将amount的值保留在栈内了（值为之前取到的1000），update之后，amount会变为900. 这明显不符合逻辑，多并发引起了数据的不一致。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何解决&lt;/h2&gt;

&lt;h3 id=&quot;versionid&quot;&gt;方式1（利用versionId）&lt;/h3&gt;

&lt;p&gt;在设计表的时候，多预留一个字段为version_id。它是一个普通的int类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;amount&lt;/th&gt;
      &lt;th&gt;version_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在定义方法的时候，要增加一个versionId进去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void updateWithIdAndVersionId(int id, int versionId,int deltaAmount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当A、B同时执行。A和B先查询记录，发现id=1，versionId=1，并将结果保存在自己的栈内。当执行update操作时，总会有一个先执行。假设A先执行，A在调用updateWithIdAndVersionId方法时，程序需要&lt;strong&gt;将versionId加1&lt;/strong&gt;，这样一来，DB中id=1的记录的version_id就是2了。当B再执行updateWithIdAndVersionId操作，它根据2个条件（id=1、versionId=1）去更新。因为此时DB中已不存在这条记录了，所以更新失败。通过这种方法就可以保证多并发对数据操作的一致性。&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/07/14/%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84DB%E6%9B%B4%E6%96%B0</link>
                <guid>http://changer119.github.io/2015/07/14/多并发下的DB更新</guid>
                <pubDate>Tue, 14 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>jekyll bootstrap主题安装</title>
                <description>&lt;p&gt;在安装bootsrap dinky主题后，本地运行jekyll是没问题的，但一上传到github.com后，就会报下面的错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The page build failed with the following error:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The submodule &lt;code&gt;_theme_packages/dinky&lt;/code&gt; was not properly initialized with a &lt;code&gt;.gitmodules&lt;/code&gt; file. For more information, see https://help.github.com/articles/page-build-failed-missing-submodule.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you have any questions you can contact us by replying to this email.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;笔者也很有耐心的去看了上文中的链接，结果怎么试都不行，后来在网上也找了很多其他的教程，依然解决不了。直到看到下面这两篇文章（&lt;a href=&quot;http://theloverz.me/note/2013/12/06/fix-failure-on-github-pages-and-jekyll/&quot;&gt;文章1&lt;/a&gt;，&lt;a href=&quot;http://dsimidzija.github.io/programming/2014/02/15/jekyll-bootstrap-themes-and-github-pages/&quot;&gt;文章2&lt;/a&gt;），才解决了问题。&lt;/p&gt;

&lt;p&gt;下面我介绍下我的步骤。&lt;/p&gt;

&lt;p&gt;1，进入博客的主目录(我的是changer119.github.io)，在.gitignore文件中添加如下内容。如果主目录下没有.gitignore文件，自己新增一个即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*.swp
_site/*
_theme_packages/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上内容表示，_site和 _theme_package两个目录都不加到git，也不上传到github。&lt;/p&gt;

&lt;p&gt;2，在主目录下删除已有的_theme_packages内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rm -r --cached _theme_packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, 重新安装jekyll bootstrap的主题。&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-theming.html#toc_3&quot;&gt;官方链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我使用的dinky主题，我在主目录下输入如下命令，碰到需要选择的时候，一直yes下去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rake theme:install git=&quot;git://github.com/sodabrew/theme-dinky.git&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，本地run一下jekyll，看看效果。在主目录下执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5，查看效果，访问&lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6，如果效果正常，就可以提交修改到github啦。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add *
git commit -m &#39;your log&#39;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://changer119.github.io/2015/07/08/jekyll-bootstrap-%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85</link>
                <guid>http://changer119.github.io/2015/07/08/jekyll-bootstrap-主题安装</guid>
                <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>maven入门</title>
                <description>&lt;h2 id=&quot;maven&quot;&gt;maven主要命令&lt;/h2&gt;

&lt;h3 id=&quot;test&quot;&gt;安装但不运行test代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Dmaven.test.skip=true
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;profile&quot;&gt;指定profile安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pint	# 给测试发的版本
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pdev	# 给开发发的版本
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;profiletest&quot;&gt;指定profile，不运行test（合并）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ mvn clean install -Pint -Dmaven.test.skip=true
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven-1&quot;&gt;maven聚合&lt;/h2&gt;
&lt;p&gt;假设有projectA，它里面聚合了projectB、projectC两个模块，projectA的pom.xml中的&lt;code&gt;&amp;lt;packaging&amp;gt;&lt;/code&gt;属性值必须为pom。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1 id=&quot;maven-2&quot;&gt;Maven参数配置&lt;/h1&gt;

&lt;h2 id=&quot;packaging-&quot;&gt;packaging 打包类型&lt;/h2&gt;

&lt;p&gt;任何一个maven工程，对应有一个pom.xml文件。这个pom.xml文件通过&lt;code&gt;&amp;lt;packaging&amp;gt;xxx&amp;lt;/packaging&amp;gt;&lt;/code&gt;来决定该工程打包的类型（打成jar包？war包？）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不填时（默认），表示打成jar包。&lt;/li&gt;
  &lt;li&gt;war，表示打成war包。&lt;/li&gt;
  &lt;li&gt;pom，表示这个工程不打包，它是其它工程的父工程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;nexus&quot;&gt;Nexus相关&lt;/h1&gt;

&lt;p&gt;Nexus安装之后，会自动配置下面这几个仓库。如图：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图片&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;这里面的仓库主要有三种类型： &lt;code&gt;hosted&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;proxy&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;group&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;hosted&lt;/strong&gt;: 主要与公司内部打交道。例如用户发布包（&lt;code&gt;mvn deploy&lt;/code&gt;）就会将包上传到&lt;code&gt;hosted&lt;/code&gt;类别的仓库中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Releases仓库：当工程pom的version为x.x.x-Release时，用户发布后会将包上传到该仓库。&lt;/li&gt;
  &lt;li&gt;Snapshots仓库：与上逻辑同。&lt;/li&gt;
  &lt;li&gt;3rd part仓库：如果有些依赖包在maven的中央仓库找不到，就需要到该依赖包的官网下载，让后将依赖包上传到该仓库中。用户下次添加依赖时，会直接到该仓库获取。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;proxy&lt;/strong&gt;: 主要与外网打交道。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Centeral仓库：从maven中央仓库下载的包都放在该仓库。&lt;/li&gt;
  &lt;li&gt;Apache Snapshots仓库：放从apache下载的包。&lt;/li&gt;
  &lt;li&gt;Codehause Snapshots仓库：放从codehause下载的包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;设置mirror后，工程只会访问镜像，如果程序访问不了镜像，也不会去访问中央工厂回到家后，无法访问mirror时，就需要注释mirror，程序才会去中央工厂下载&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;mvn-deploy&quot;&gt;发布（mvn deploy）&lt;/h2&gt;

&lt;p&gt;要将包发布到私服上，需要先在pom中设置&lt;code&gt;&amp;lt;distributionManagement&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;server&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图片1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pic2&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven-3&quot;&gt;Maven的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;有3套生命周期：clean的生命周期、compile的生命周期、site的生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下图列出了执行mvn clean和mvn install需要完成的步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-2@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-3@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件的配置&lt;/h2&gt;

&lt;p&gt;表示在执行完validate之后，就会执行jar和test-jar操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../_images/QQ20150711-4@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;**在父级pom中，有&lt;code&gt;&amp;lt;pluginsManagement&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;标签，在它里面定义的内容不能够被子模块直接继承，需要在子模块中手动添加groupid和archtypeId才行**&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
                <link>http://changer119.github.io/2015/07/08/Maven%E5%85%A5%E9%97%A8</link>
                <guid>http://changer119.github.io/2015/07/08/Maven入门</guid>
                <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>测试图片显示</title>
                <description>
&lt;p&gt;这是一张图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://changer119.github.io/assets/images/1.jpg&quot; alt=&quot;图片说明&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://changer119.github.io/2015/07/07/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87</link>
                <guid>http://changer119.github.io/2015/07/07/测试使用图片</guid>
                <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>java枚举类型初体验</title>
                <description>&lt;p&gt;Enum是JDK5引入的。有了Enum类型后，对于常量的处理更加方便。&lt;/p&gt;

&lt;p&gt;以前定义常量一般是这样的：&lt;/p&gt;

&lt;p&gt;```
Constant.java&lt;/p&gt;

&lt;p&gt;public interface Constant{
	public final PI = 3.14;
	public fianl G = 9.8;
}
```&lt;/p&gt;

&lt;p&gt;以前这些常量可能分散在不同的文件中，缺乏统一的管理，使用不方便。&lt;/p&gt;

&lt;p&gt;利用Enum类型，可以将常量定义成如下形式：&lt;/p&gt;

&lt;p&gt;```
ColorEnum.java&lt;/p&gt;

&lt;p&gt;public enum ColorEnum{
	RED, GREEN, YELLOW;
}
```&lt;/p&gt;

&lt;p&gt;如果觉得上面的枚举太过简单，可以给ColorEnum添加方法。&lt;/p&gt;

&lt;p&gt;```
public enum Color {
    // 必须先定义枚举类Color的实例
    Red(1, “红色”),
    Green(2, “绿色”),
    Yellow(3, “黄色”),
    Pink(4, “粉红色”);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final int id;
private final String description;


// 根据id值得到对应的description
public static String getDescription(int id){
    for(Color item : Color.values()){
        if(item.getId() == id){
            return item.getDescription();
        }
    }
    return null;
}
// 根据id值得到对应的枚举实例
public static Color getColor(int id){
    for(Color item : Color.values()){
        if(item.getId() == id){
            return item;
        }
    }
    return null;
}
// 根据id值得到对应的枚举实例
public static Color valueOf(int id){
    switch (id){
        case 1:
            return Color.Red;
        case 2:
            return Color.Green;
        case 3:
            return Color.Yellow;
        case 4:
            return Color.Pink;
        default:
            return  null;
    }
}

//覆盖方法
@Override
public String toString() {
    return this.id+&quot;_&quot; + this.description;
}

Color(int id, String description) {
    this.id = id;
    this.description = description;
}

public int getId() {
    return id;
}

public String getDescription() {
    return description;
}

// 枚举类里面可以添加main方法
public static void main(String[] args){
    int id = 2;
    Color c = Color.getColor(2);
    System.out.println(c);
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义枚举类时，枚举实例必须放在最前面，并且已&lt;code&gt;;&lt;/code&gt;分号隔开。&lt;/li&gt;
  &lt;li&gt;枚举实例&lt;code&gt;Red(1, &quot;红色&quot;)&lt;/code&gt;，是根据枚举类的定义得来的。（枚举类有id, description两个成员变量）&lt;/li&gt;
  &lt;li&gt;这种枚举类主要用在数据库的状态字段中。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://changer119.github.io/2015/07/07/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8</link>
                <guid>http://changer119.github.io/2015/07/07/Java枚举类型使用</guid>
                <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Intellij入门</title>
                <description>&lt;h2 id=&quot;svnmaven&quot;&gt;导出svn上的maven工程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;ld&lt;/li&gt;
  &lt;li&gt;代码checkout到本地后，查看代码发现都有红色的问号（表示有错误）。这是因为Intellij没有自动刷新导致的。只要点击Intellij右侧MavenProjects，再点击刷新图标即可。
&lt;img src=&quot;../_images/QQ20150707-1@2x.png&quot; alt=&quot;图片说明&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;intellij&quot;&gt;Intellij常用快捷键&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;组合键&lt;/th&gt;
      &lt;th&gt;实现的功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;替换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;alt + F7&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找方法或者类被引用的地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + shift + F&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全工程搜索某字符串内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;cmd + N&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;生成构造方法或者getter/setter&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
                <link>http://changer119.github.io/2015/07/07/Intellij%E4%BD%BF%E7%94%A8</link>
                <guid>http://changer119.github.io/2015/07/07/Intellij使用</guid>
                <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>公司巨变</title>
                <description>&lt;p&gt;2015年6月末到7月初，公司发生了一场巨变，很多的人员主动离职。&lt;/p&gt;

&lt;p&gt;事情的起因是6月最后一个周五，突然收到李总（总裁）的邮件，说因为产品战略与公司产生分歧，提出离职。事情一出，大家就在议论，到底是什么分歧。李总说的与公司战略不一致，其实就是说的他跟CEO的意见不一致。过了大约一个小时，人力资源的负责人立马发邮件通知大家，说公司的某一项产品（由李总负责）将下线。邮件同时否认了一些谣言，并且提到了李总和另外一位核心员工的离职。&lt;/p&gt;

&lt;p&gt;本以为事情到此为止，谁知道接下来的周一，公司很多人集体离职。我猜想他们肯定都是被李总拉出去单干了。这里面有很多老员工，也有一些新进来才2-3各月的员工。他们都是按照一个团队去的，既有PM、后台、前端，还有不同业务线的人员。这些人在公司的工作交接也很神速，估计每个人只用了1-2个小时就完成交接了。等我周四从家里回到单位时，要离职的人都离开了。&lt;/p&gt;

&lt;p&gt;因为这些骨干人员的离职，CEO发邮件鼓励大家，并提及了ESOP计划，并且现在正准备开启。希望这可以团结大家吧。&lt;/p&gt;
</description>
                <link>http://changer119.github.io/2015/07/02/%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A8%E5%8F%98</link>
                <guid>http://changer119.github.io/2015/07/02/公司的巨变</guid>
                <pubDate>Thu, 02 Jul 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Git学习</title>
                <description>&lt;h2 id=&quot;pushgithub&quot;&gt;本地push更新到github&lt;/h2&gt;
</description>
                <link>http://changer119.github.io/2015/06/24/Git%E5%AD%A6%E4%B9%A0</link>
                <guid>http://changer119.github.io/2015/06/24/Git学习</guid>
                <pubDate>Wed, 24 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Linux常用命令</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;查看端口使用情况&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ netstat -anp | grep 9999
&amp;gt; tcp  0  0    :::9999      :::*       LISTEN         21209/java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21209就是占用该端口应用程序的PID&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;查找文件&lt;/h3&gt;

&lt;p&gt;Linux中查找文件有以下几种方式：&lt;/p&gt;

&lt;p&gt;1， &lt;strong&gt;find命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```
find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定操作&gt;&lt;/指定操作&gt;&lt;/指定条件&gt;&lt;/指定目录&gt;&lt;/p&gt;

&lt;h1 id=&quot;my&quot;&gt;搜索当前目录下文件名以my开头的文件或者文件夹&lt;/h1&gt;
&lt;p&gt;$ find . -name ‘my&lt;em&gt;’	
# 搜索根目录（/）下文件名以my开头的文件或者文件夹，并显示详细信息
$ find / -name ‘my&lt;/em&gt;’ -al
```&lt;/p&gt;

&lt;p&gt;2， &lt;strong&gt;locate命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用&lt;strong&gt;updatedb&lt;/strong&gt;命令，手动更新数据库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
# 搜索/etc/目录下以sh开头的文件
$ locate /etc/sh*
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3， &lt;strong&gt;which命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在linux系统中，一个命令（如&lt;strong&gt;ls&lt;/strong&gt;）可能对应多个可执行的文件。用户在终端中输入命令时，linux系统究竟用的是/bin/下面的命令还是/local/bin下面的？&lt;/p&gt;

&lt;p&gt;这时就可以用which命令。它会查找$PATH变量，遇到第一个匹配的命令就返回。这第一个命令也就是系统默认调用的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ which grep
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4， &lt;strong&gt;whereis命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ whereis grep
&lt;/code&gt;&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/06/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</link>
                <guid>http://changer119.github.io/2015/06/16/Linux常用命令</guid>
                <pubDate>Tue, 16 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>测试服务器发版备忘</title>
                <description>&lt;h2 id=&quot;nginx&quot;&gt;配置nginx&lt;/h2&gt;
&lt;p&gt;53服务器上nigix配置文件&lt;code&gt;/etc/nginx/conf.d/default.conf&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;配置前端的代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
    # 增加前端静态文件的访问路径
    location /zydmanagec {
        #root   /usr/share/nginx/html;
        alias   /enniu/www/web-audit-static-collection/build;
        index  index.html index.htm;
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浏览器请求&lt;code&gt;192.168.2.53/zydmanagec&lt;/code&gt;时，会自动将请求路由到&lt;code&gt;/enniu/www/web-audit-static-collection/build&lt;/code&gt;路径下。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置后端的代理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
    # 增加后端的路由代理
    location /zydservicec/web-audit {
        proxy_pass  http://192.168.2.53:9999/web-audit;
        #Proxy Settings
        proxy_cookie_path /web-audit/ /;
        proxy_set_header   Host   $host;
        proxy_set_header   Referer $http_referer;
        proxy_set_header   Cookie $http_cookie;
        proxy_set_header   X-Real-IP  $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用户在点击前端的按钮后，会请求后端的业务逻辑，请求的路径会变为&lt;code&gt;192.168.2.53/zydservice/web-audit&lt;/code&gt;，nginx会将该url路由到&lt;code&gt;http://192.168.2.53:9999/web-audit&lt;/code&gt;路径下，后端进行业务逻辑处理。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;让配置生效&lt;/h3&gt;
&lt;p&gt;让配置生效有两种方式：&lt;/p&gt;

&lt;h4 id=&quot;nginx-1&quot;&gt;1，重启nginx&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;
$ sudo service nginx restart
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;2，重新加载配置文件（推荐）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;
$ sudo service nginx reload
&lt;/code&gt;&lt;/p&gt;

</description>
                <link>http://changer119.github.io/2015/06/12/%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E7%89%88%E5%A4%87%E5%BF%98</link>
                <guid>http://changer119.github.io/2015/06/12/测试服务器发版备忘</guid>
                <pubDate>Fri, 12 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Linux下安装多个tomcat实例</title>
                <description>&lt;h2 id=&quot;tomcat&quot;&gt;拷贝tomcat目录&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;
$ cp /..../tomcat  /..../tomcat_new
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;修改配置&lt;/h2&gt;

&lt;h3 id=&quot;etcprofile&quot;&gt;修改&lt;code&gt;/etc/profile&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
# 在文件的末尾加上下面这一段
# added by fcjiang @2015-06-12 for tomcat-7-9999-test
CATALINA_3_BASE=/enniu/tomcat-7-9999-test
CATALINA_3_HOME=/enniu/tomcat-7-9999-test
TOMCAT_3_HOME=/enniu/tomcat-7-9999-test
export CATALINA_3_BASE CATALINA_3_HOME TOMCAT_3_HOME
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;etcprofile-1&quot;&gt;激活&lt;code&gt;/etc/profile&lt;/code&gt;修改内容&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ source /etc/profile
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcatnewbincatalinash&quot;&gt;修改&lt;code&gt;.../tomcat_new/bin/catalina.sh&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
# 在该文件的最前面添加一下内容
# added by fcjiang @2015-06-12 for tomcat-7-9999-test
export JAVA_HOME=$JAVA_HOME
export PATH=$PATH
export CLASSPATH=$CLASSPATH
export CATALINA_BASE=$CATALINA_3_BASE
export CATALINA_HOME=$CATALINA_3_HOME
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tomcatnewserverxml&quot;&gt;修改tomcat_new中server.xml文件&lt;/h3&gt;
&lt;p&gt;文件路径&lt;code&gt;.../tomcat_new/conf/server.xml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要修改三个地方：&lt;/p&gt;

&lt;p&gt;1，修改应用访问端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;connector port=&quot;9999（修改）&quot; protocol=&quot;HTTP/1.1&quot; connectiontimeout=&quot;20000&quot; redirectport=&quot;8443&quot; uriencoding=&quot;UTF-8&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;2，修改AJP端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;connector port=&quot;9009（修改）&quot; protocol=&quot;AJP/1.3&quot; redirectport=&quot;8443&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;3，修改tomcat关闭端口&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;server port=&quot;9005（修改）&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
```

**至此，新加的tomcat的配置已经完成**


## 启动新的tomcat

```
$ .../tomcat_new/bin/catalina.sh start
```


&lt;/server&gt;
</description>
                <link>http://changer119.github.io/2015/06/12/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AAtomcat%E5%AE%9E%E4%BE%8B</link>
                <guid>http://changer119.github.io/2015/06/12/Linux下安装多个tomcat实例</guid>
                <pubDate>Fri, 12 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Redis入门</title>
                <description>&lt;h2 id=&quot;redis&quot;&gt;安装redis&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://yijiebuyi.com/blog/d8ab4b444c16f42cefe30df738a42518.html&quot;&gt;链接 亲测可用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;redis-1&quot;&gt;启动redis&lt;/h2&gt;
&lt;p&gt;### 启动redis服务器
&lt;code&gt;
$ /usr/local/bin/redis-server /etc/redis.conf
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上命令，表示参照配置文件&lt;code&gt;/etc/redis.conf&lt;/code&gt;启动redis服务器。配置文件中会设置redis持久化文件存放的路径（本机放在&lt;code&gt;/opt/redis/&lt;/code&gt;中）。&lt;/p&gt;

&lt;h3 id=&quot;redis-2&quot;&gt;利用客户端连接redis服务器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ /usr/local/bin/redis-cli
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上命令是连接localhost中得redis服务器（并且端口是默认的&lt;code&gt;6379&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;如果需要连接远程主机上的redis服务器，并且服务器端口不是默认的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ /usr/local/bin/redis-cli -h 192.168.1.100 -p 6388
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;断开客户端&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;
$ quit
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;redis-3&quot;&gt;命令行使用redis&lt;/h2&gt;

&lt;h2 id=&quot;javaredis&quot;&gt;java程序使用redis&lt;/h2&gt;
</description>
                <link>http://changer119.github.io/2015/06/11/Redis%E5%85%A5%E9%97%A8</link>
                <guid>http://changer119.github.io/2015/06/11/Redis入门</guid>
                <pubDate>Thu, 11 Jun 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>跨域常用的方式以及原理</title>
                <description>&lt;p&gt;这篇文章紧接上一篇“&lt;a href=&quot;http://changer119.cn/fcjiang/?p=109&quot;&gt;ajax跨域访问&lt;/a&gt;”。这里主要罗列下跨域常用的方式以及跨域的原理。&lt;/p&gt;

&lt;h2 id=&quot;script&quot;&gt;使用script的方式&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;实现一&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
function jsonpCallback(result) {  
//alert(result);  
for(var i in result) {  
alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
}  
}  
var JSONP=document.createElement(&quot;script&quot;);  
JSONP.type=&quot;text/javascript&quot;;  
JSONP.src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;  
document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);  
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实现二&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    function jsonpCallback(result) {  
        alert(result.a);  
        alert(result.b);  
        alert(result.c);  
        for(var i in result) {  
            alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
        }  
    }  
&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;使用jQuery的方式&lt;/h2&gt;

&lt;h3 id=&quot;getjson&quot;&gt;实现一：$.getJSON&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $.getJSON(&quot;http://crossdomain.com/services.php?callback=?&quot;,  
    function(result) {  
        for(var i in result) {  
            alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
        }  
    });  
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ajax&quot;&gt;实现二：$.ajax&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $.ajax({  
        url:&quot;http://crossdomain.com/services.php&quot;,  
        dataType:&#39;jsonp&#39;,  
        data:&#39;&#39;,  
        jsonp:&#39;callback&#39;,  
        success:function(result) {  
            for(var i in result) {  
                alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  
            }  
        },  
        timeout:3000  
    });  
&amp;lt;/script&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;get&quot;&gt;实现三：$.get&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $.get(&#39;http://crossdomain.com/services.php?callback=?&#39;, {name: encodeURIComponent(&#39;tester&#39;)}, function (json) { for(var i in json) alert(i+&quot;:&quot;+json[i]); }, &#39;jsonp&#39;);  
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 jsonCallback 是客户端注册的，获取 跨域服务器 上的json数据 后，回调的函数。&lt;/p&gt;

&lt;h2 id=&quot;jsonp&quot;&gt;JSONP的原理&lt;/h2&gt;

&lt;p&gt;1，首先在客户端注册一个callback, 然后把callback的名字传给服务器。&lt;/p&gt;

&lt;p&gt;2，服务器先生成 json 数据。&lt;/p&gt;

&lt;p&gt;3，服务器端将生成的json数据作为入参，放置到callback的回调函数名中。这样就生成了一段js语法的文档，返回给客户端。&lt;/p&gt;

&lt;p&gt;4，客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）&lt;/p&gt;

</description>
                <link>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86</link>
                <guid>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/跨域常用的方式以及原理</guid>
                <pubDate>Tue, 24 Mar 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>ajax跨域访问</title>
                <description>&lt;p&gt;ajax跨域访理解起来有点绕，网上能够搜到很多相关的帖子，但基本上都是抄至同一个人。 鉴于这个原因，我自己整理一下ajax跨域访问的实例，希望帮助到更多人。&lt;/p&gt;

&lt;p&gt;我在本地有一个Java Web的应用，它需要访问远程主机（新浪SAE）的某个应用中的action。利用普通的ajax交互。&lt;/p&gt;

&lt;p&gt;本地应用中ajax请求的代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/1.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/1.png&quot; alt=&quot;1&quot; width=&quot;878&quot; height=&quot;196&quot; class=&quot;alignnone size-full wp-image-110&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;运行后得到错误提示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/2.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/2.png&quot; alt=&quot;2&quot; width=&quot;875&quot; height=&quot;130&quot; class=&quot;alignnone size-full wp-image-111&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由上可知，通过普通的ajax来获取远程主机的数据（跨域访问）是不行的。&lt;/p&gt;

&lt;p&gt;怎么样才能实现ajax的跨域访问呢？利用JSONP来进行ajax交互。具体JSONP是什么东西，大家可以google一下，略去。&lt;/p&gt;

&lt;p&gt;下面介绍如何利用JSONP进行跨域访问。 本地应用中ajax请求代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/3.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/3.png&quot; alt=&quot;3&quot; width=&quot;810&quot; height=&quot;240&quot; class=&quot;alignnone size-full wp-image-112&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/4.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/4.png&quot; alt=&quot;4&quot; width=&quot;1272&quot; height=&quot;267&quot; class=&quot;alignnone size-full wp-image-113&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当然，要实现ajax跨域仅仅在客户端改用JSONP还是不行的，必须要远程主机上的action配合才行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;远程主机action的代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/5.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/5.png&quot; alt=&quot;5&quot; width=&quot;884&quot; height=&quot;383&quot; class=&quot;alignnone size-full wp-image-114&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;客户端在拿到ajax返回的数据如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/6.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/6.png&quot; alt=&quot;6&quot; width=&quot;803&quot; height=&quot;121&quot; class=&quot;alignnone size-full wp-image-115&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;客户端jsonp的回调函数如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/7.png&quot;&gt;&lt;img src=&quot;http://changer119.cn/fcjiang/wp-content/uploads/2015/03/7.png&quot; alt=&quot;7&quot; width=&quot;606&quot; height=&quot;63&quot; class=&quot;alignnone size-full wp-image-116&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【注】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;经我实测，在客户端中不定义jsonpCallbackFunc方法，跨域也能够成功。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跨域获得的数据能够自动传入ajax的success:function(data){}回调函数，data就是跨域所得数据。&lt;/strong&gt;&lt;/p&gt;

</description>
                <link>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/ajax%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE</link>
                <guid>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/03/24/ajax跨域访问</guid>
                <pubDate>Tue, 24 Mar 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>使用快盘同步</title>
                <description>&lt;p&gt;我算一个深度的Dropbox用户，从2009年就开始使用，特别是工作后经常的单位和家两地切换，Dropbox就使用的更加频繁了。有了Dropbox后，我就抛掉了U盘，文件图片之类的全部通过Dropbox同步搞定。大概从2014年11-2月开始Dropbox被GFW墙掉了，Dropbox一直提示“SSL连接出错”。有时候好不容易连接上了，同步了一两个文件后又抽疯，后面就直接罢工了。刚开始碰到这种情况时，我花了九牛二虎之力去网上搜解决方案。修改Host、配置代理，我都试过了，Dropbox依然处在大洋彼岸，而我始终连接不上。没有了Dropbox，同步文件非常的不方便，但又不愿意使用115网盘，就这样忍受着。&lt;/p&gt;

&lt;p&gt;今天，因为要在单位和家里同时修改一份简历的缘故。我又想起了Dropbox，但天朝依然没有将其解封。无奈之下，我搜索“Dropbox 替代”，在知乎找到了有关讨论&lt;a href=&quot;http://www.zhihu.com/question/19647014&quot;&gt;点击跳转&lt;/a&gt;。大致浏览一遍后我选择了“金山快盘”。注册快盘后，在登录Web端时，居然出现了错误，刷新后才看到内容。看来快盘自己还有待改进。安装PC端的同步客户端后，它在本地建立了一个主目录，里面存放要同步的文件。简单那试用后，发现快盘做的还不错。基本功能上，已经做得和Dropbox类似了，右侧还会弹出一个panel，用户显示同步的相关信息。&lt;/p&gt;

&lt;p&gt;以后就会用快盘替代Dropbox。&lt;/p&gt;

&lt;p&gt;【注】中国的互联网用户好痛苦，先是用国外最好的服务，后因为GFW，总要切换到国内的山寨产品上来。&lt;/p&gt;

</description>
                <link>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2015/03/13/%E4%BD%BF%E7%94%A8%E5%BF%AB%E7%9B%98%E5%90%8C%E6%AD%A5</link>
                <guid>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2015/03/13/使用快盘同步</guid>
                <pubDate>Fri, 13 Mar 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>DOM对象和jQuery对象转换</title>
                <description>&lt;h2 id=&quot;dom&quot;&gt;DOM对象&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[javascript]
//DOM对象是JS原生的对象，它具备自己一套方法。
var aa = document.getElementById(&quot;aa&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;jQuery对象&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[javascript]
//jQuery对象通过“选择器”获取，$aa是一个数组对象
var $aa = $(&quot;#aa&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery-8211-dom&quot;&gt;从jQuery对象 –&amp;gt; DOM对象&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[javascript]
//方式1
var index = 0;
var bb = $aa[index];
//方式2
var bb = $aa.get(index);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dom-8211-jquery&quot;&gt;从DOM对象 –&amp;gt; jQuery对象&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[javascript]
//通过$()方式来转化
$cc = $(aa);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt;和&lt;strong&gt;$(this)&lt;/strong&gt; 就是上面介绍的DOM和jQuery对象的2种特殊情况。&lt;/p&gt;

&lt;p&gt;看看下面的一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[html]
&amp;lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;onclickHandler(this)&quot; /&amp;gt;
&amp;lt;input type=&quot;button&quot; value=&quot;点击2&quot; onclick=&quot;onclickHandler2($(this))&quot; /&amp;gt;
&amp;lt;script&amp;gt;
function onclickHandler(domObj){
    //this作为实参传递进来，代指input的DOM对象，输出&quot;点击&quot;
    console.log(domObj.value);
}
function onclickHandler2(jqObj){
    //$(this)作为实参传递进来，代指input的jQuery对象，输出&quot;点击2&quot;
    console.log(jqObj[0].value);
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/01/13/DOM%E5%AF%B9%E8%B1%A1%E5%92%8CjQuery%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2</link>
                <guid>http://changer119.github.io/%E7%A0%94%E7%A3%A8%E6%8A%80%E6%9C%AF/2015/01/13/DOM对象和jQuery对象转换</guid>
                <pubDate>Tue, 13 Jan 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>2014年底陪护老爸</title>
                <description>&lt;p&gt;2014年，真是一个极其难熬的年份，对于老爸而言更是这样。春节那会，老爸去衡阳市附一医院做了一个颈椎手术，修养了8天多才出院。这到年底了，老爸又因为呼气困难，到衡阳市中心医院住院。这次住院了12天，直到2015年1月2日才出院。老爸生病住院期间，我和老弟都回衡阳，陪在他身边。下面我就简单的记录下生病住院的一些过程。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2014-12-23 周二&lt;/h2&gt;

&lt;p&gt;这天是礼拜二，老妈和老爸早上6点多到烟洲镇上赶衡阳的班车，准备到衡阳市中心医院看病。其实，早在几天前，老爸就呼气困难，每天晚上都无法安睡。只要平躺下来，就呼气不赢，必须坐起来，直着身子，顺着呼气才好。每天晚上老妈醒来的时候，总会老爸坐起来垂着头在打瞌睡。老妈看着心里也挺难受的，就准备陪老爸去衡阳医院看看。所以，等过了周末和周一（农历初一，老妈迷信），礼拜二他们两就来到衡阳中心医院了。&lt;/p&gt;

&lt;p&gt;在表姐TanMing的帮助下，老爸直接住院了，因为他当时的情况已十分危急。医生需要帮他平稳呼吸，同时需要拍片子，诊断呼气困难的原因。当天，老妈陪着老爸做了一个普通的CT和一个增强CT。增强CT显示老爸肺部有肿瘤。老妈给我打电话，她就哭了，我在挂完电话后也止不住哭了。老弟买了当晚的火车，明天早上到家。我想这时候老妈需要我们在她身边。老爸不知道情况，老妈也只是告诉她是肺气肿，让他安心休息，过几天就好。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2014-12-24 周三&lt;/h2&gt;

&lt;p&gt;早上4点多，老弟就到衡阳了，他在KFC睡到天亮后就直奔医院而去。新的一天，他将慢慢接过老妈身上的担子，与她一起担着。老弟对爸妈是非常贴心的，每次家里有一点儿事，他总是能及时从广东赶回来，而每次又都是把事情处理好后再回广东的。这一天，老弟应该找医生了解了老爸的病情，他告诉我老爸是肺衰竭、心脏衰竭、肺部肿瘤。我还在杭州，只能干着急，在网上搜索了一些有关肺部肿瘤的知识，希望能够多了解点，对了解老爸的病情有帮助。我想知道确证肿瘤良、恶性的方法，让老弟进一步跟医生多聊聊。&lt;/p&gt;

&lt;p&gt;我决定回一趟家，去看看老爸。确定周五晚上出发，休3天年假，加上元旦3天，一共可在家呆8天，希望能够陪着老爸老妈，现在我是他们的支柱与依靠。因为23号来的时候，老妈未曾想到会住院，所以今天她决定跟老弟回一趟家。一来带一些生活用品到医院来，二来安排下家里的事情。因为老妈晕车厉害，老弟跟她一起坐车回家去。老爸晚上就只能用八宝粥充饥了。明天早上老弟会再来陪护老爸的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2014-12-25 周四&lt;/h2&gt;

&lt;p&gt;老弟早上从家里坐班车到衡阳，老妈在家呆着。我在杭州上班。&lt;/p&gt;

&lt;p&gt;老弟估计是早上9点多到医院的，老爸拿八宝粥当早饭。中饭是老弟从医院外面的小炒店给炒的猪肚。听说医院食堂的饭菜很难吃，老弟挺有心的从外面炒了老爸最爱吃的菜。老爸很喜欢猪肚的嚼头，每年过年的时候，如果有猪肚，他都会拿出来好好的说一道，因为在他心中，这是最好的菜了。我虽然人在杭州，但上班也没什么心思，上班期间总会到网上搜一些有关肺癌的信息。&lt;/p&gt;

&lt;p&gt;下班后，我跟老弟聊天，让他周五晚上回家，我周六会接手照顾老爸。这天晚上，我让小朱也跟老爸老妈聊了会天，主要是安慰下他们两。小朱晚上给了我200块钱，让我带回去给老爸买一些营养品吃。这天晚上，老弟没有出去找宾馆住，而是在网吧里待了整整一夜。他在医院周边问了下，住宿大概要60-70一晚上，而听说火车站那边有40多一晚上的。他本来准备去火车站那边住宿的，但考虑到已经夜深，所以索性在网吧过了。后来听他自己说，那个网吧环境还可以，就是睡着之后脚还是很凉的。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2014-12-26 周五&lt;/h2&gt;

&lt;p&gt;我准备坐晚上6点多火车回家，预计周六早上9点样子到。我今天没干什么活，只是把几个bug走了下单。下午4点的时候就下班赶火车去了。&lt;/p&gt;

&lt;p&gt;根据之前的安排，老弟今天下午已经坐2点钟的班车回家里了。老爸的晚饭，老弟应该准备好了，但我不知道老爸有没有用医院的微波炉热一下晚饭。我问了老爸，他是说热过了，但按照他一贯嫌麻烦的习惯，我觉得很大可能他就直接吃冷饭了。我当时就跟老爸说过，周六的早饭我送给他吃，免得再吃冷的八宝粥。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;2014-12-27 周六&lt;/h2&gt;

&lt;p&gt;火车晚点了，到了9点多还在衡山站，估计到衡阳得10点了。老爸估计也饿了，他打电话给我，说早饭就不用我带了，他吃了八宝粥了。老爸很聪明，他用一个大水杯，装满开水后将瓶装八宝粥放进去，等八宝粥温了再吃。我下了火车就走路去医院，医院过了衡阳的老大桥左拐就到了。在前往医院的路上，我看到路边有绿豆沙饼买，就买了一点过去。我要买这个绿豆饼，是因为它像我之前从杭州带回家的板栗饼，老爸挺喜欢板栗饼的。&lt;/p&gt;

&lt;p&gt;来到医院，看到老爸正在输液，鼻孔里还塞一根导管在吸氧。我叫了一声“爸爸”，老爸老实地看着我，没有太多的表情，因为自己的家人来了。老爸脸上的皱纹更深了，人也变瘦了很多。几句对话后，老爸就让我不要在病房待了，他说这里是呼吸科，可能有传染。这句话后来我在老爸老妈那里听到n回，他们就是担心我们年轻人的身体。&lt;/p&gt;

&lt;p&gt;我从病房里出来后，就在周边熟悉了下环境。中饭是在一家蒸菜馆买的蒜苗炒猪肚和辣椒炒肉。老爸嫌辣椒炒肉都是肥肉不愿意吃。蒜苗炒猪肚他还是很喜欢的。衡阳的菜都比较辣，而且加了生姜，这些老爸是忌食的，但没有办法，每顿还得给他买。吃完中饭后，我去找老爸的主治医生了解病情。她给我看了CT检查结论，给我分析说老爸可能是肺癌晚期。我听着这些没有太大的情绪波动，但当我跟老妈或者老爸聊天时，心里就会有种想哭劲。有时候总会在想为什么自己会碰上这种事情？转念又得安慰自己，如果真是这样，那我还得接受。&lt;/p&gt;

&lt;p&gt;晚饭给老爸买的什么，我已记不太清楚了。反正是等老爸吃好晚饭，给他打好开水后，老爸又催促我出去了。照顾老爸的这一天，我跟他待在一起的时间并不长，只是在饭点的时候给他送饭来。有时我特别 想跟他多待一会，哪怕随便聊聊天也好，但老爸总是考虑我的健康，不让我在病房长待。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;2014-12-28 周日&lt;/h2&gt;

&lt;p&gt;老妈和老弟今天不来衡阳，我继续一个人照顾老爸。说是照顾，其实也就送3餐饭而已。&lt;/p&gt;

&lt;p&gt;中午那会天气很好，我陪着老爸下来，在市医院斜对面的公园转了一会。后来又走到湘江边站了一会，老爸还是有点儿出气不赢，我就陪老爸会病房了。在外面总共就转了30分钟吧。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2014-12-29 周一&lt;/h2&gt;

&lt;p&gt;老妈和老弟今天到衡阳，我们需要一块商量下老爸后续检查的事情。看到老妈时发现她皱纹又深了，她带着一顶淡粉红色的帽子，穿着暗绿色的羽绒服。老爸的病估计让老妈着急、担心了不少。老弟也瘦了，留着很长的头发，感觉有点儿邋遢但人蛮精神的。&lt;/p&gt;

&lt;p&gt;老妈会在病房一直陪着老爸，我和老弟就多半在宾馆里呆着。老爸估计也不太会跟老妈唠家常，因为他本来就是一个话不多的人。&lt;/p&gt;

&lt;p&gt;中午太阳不错，我们又到湘江边转转去了。老爸总是站着，看着江对面，跟老弟聊着“衡阳城市还是很大啊”，而我就陪着老妈坐一边的阶梯上。老妈担心老爸的身体，要真是癌症的话，老妈可怎么过啊？她聊着的时候，哭了，我试图从肩上搂抱着老妈，但她不太愿意，因为她觉得自己以前等过肺结核，怕影响到我。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;2014-12-30 周二&lt;/h2&gt;

&lt;p&gt;支气管镜检查&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;2014-12-31 周三&lt;/h2&gt;

&lt;p&gt;岳屏公园喝茶打牌&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;2015-01-01 周四&lt;/h2&gt;

&lt;p&gt;天气不好没有出去转&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;2015-01-02 周五&lt;/h2&gt;

&lt;p&gt;老爸出院，老妈和老弟陪老爸回家，我从衡阳坐火车回杭州。&lt;/p&gt;
</description>
                <link>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2015/01/08/2014%E5%B9%B4%E5%BA%95%E9%99%AA%E6%8A%A4%E8%80%81%E7%88%B8</link>
                <guid>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2015/01/08/2014年底陪护老爸</guid>
                <pubDate>Thu, 08 Jan 2015 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>老爸呼吸困难住院</title>
                <description>&lt;p&gt;今天杭州天气很好，冬日的阳光灿烂而且温暖，但不知道老家衡阳的天气如何。今天老妈陪着老爸去衡阳市中心医院看病去。我的心情也十分沉重。&lt;/p&gt;

&lt;p&gt;今年老爸的运势就特别不好，春节的时候因为颈椎去南华附一动过手术，住院7-8天。手术康复出院后，老爸又重操旧业，烟酒一样都不能少，本来身体就不太好，这样一来，到了冬天冷的时候就各种毛病都犯了。一周之前，我打电话回去的时候就听老妈说爸爸最近呼吸困难，他一直不愿意到医院去看，硬是拖了好几天，后来越来越严重了才跑到镇上去输液。本来慢慢好起来了，上周六我再打电话回去的时候由变严重了。实在拖不下去了，今天老妈带着老爸到衡阳市中心医院检查了。&lt;/p&gt;

&lt;p&gt;从家里到镇上去坐中巴车有一段距离，老爸肯定是走不过去的，他骑摩托车估计也不太可能，我都不知道他们怎么到镇上的。上午10点多的时候，老弟电话过来告诉我老爸老妈已经到医院了，正在准备办理住院手续。有一些检查结果要到下午5点多才能够拿到，还没有确切的结论，但医生还是认为老爸的病情比较严重。我下午2点半的时候打电话过去，老妈说医生刚刚跟老弟通过电话了，说是情况不理想。老妈在电话里头已经在哭了，我只能安慰她说老爸没事的。其实我自己的心里也不好受，我也有种想哭的冲动，但我不能表现出来，我是整个家庭的依靠，我要坚强的承担起来。老弟今天晚上的火车，明天早上到衡阳。他会陪着老妈在医院护理老爸。老弟在身边，不仅可以去跑跑手续，也可以陪老妈说说话。&lt;/p&gt;

&lt;p&gt;晚上7点多的样子，我又打电话给老爸，他说妈妈下楼去了，说是买吃的去了。原来，老爸吃了点中午剩下的盒饭，老妈估计还没吃，剩饭也没有了，只好再下去买点东西吃。听到这段的时候，我心里揪着难受，她一个人这么冷的天还得去完全不熟悉的地方去买晚饭。老妈是一个坚强的女性，她的肩膀能够扛起一切，但我还是希望不是她一个人来扛。我和老弟应该扛起来。老弟能够围绕在爸妈身边，爸妈有需要时，他总是第一个站出来，我真的非常的感谢有这么好的一个弟弟。他才有一个哥哥的风范。挂断这个电话后，我当着Sue的面哭了。哭完之后，我会更坚强，爸妈、老弟，我们会一起面对这些困难的。&lt;/p&gt;

&lt;p&gt;2014年快过去了，这是老爸的一个坎，跨过去就一切都好了。&lt;/p&gt;
</description>
                <link>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2014/12/23/%E8%80%81%E7%88%B8%E5%91%BC%E5%90%B8%E5%9B%B0%E9%9A%BE%E4%BD%8F%E9%99%A2</link>
                <guid>http://changer119.github.io/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/2014/12/23/老爸呼吸困难住院</guid>
                <pubDate>Tue, 23 Dec 2014 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
